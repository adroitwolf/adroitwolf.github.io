<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java写投票脚本自动化初探</title>
      <link href="/2019/06/07/java%E5%86%99%E6%8A%95%E7%A5%A8%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/06/07/java%E5%86%99%E6%8A%95%E7%A5%A8%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java写投票脚本自动化初探"><a href="#java写投票脚本自动化初探" class="headerlink" title="java写投票脚本自动化初探"></a>java写投票脚本自动化初探</h1><p>由于大学里面有一些任务需要投票，而又不想劳烦他人去帮我，所以打算自己写一个脚本来实现自动投票的功能。这里记录一下我的整个过程。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>java8<br>selenium3 实现chrome自动化的jar包<br>AUTolt 模拟键盘操作的软件</p><ul><li>导入selenium3</li></ul><p>这里我用的maven导入的，代码如下：</p><pre><code class="xml">      &lt;dependency&gt;           &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;           &lt;artifactId&gt;selenium-server&lt;/artifactId&gt;           &lt;version&gt;3.141.59&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;       &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;       &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;       &lt;version&gt;3.14.0&lt;/version&gt;   &lt;/dependency&gt;</code></pre><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p><img src="https://s2.ax1x.com/2019/06/08/VDUrOx.png" alt></p><h2 id="利用代码启动chrome"><a href="#利用代码启动chrome" class="headerlink" title="利用代码启动chrome"></a>利用代码启动chrome</h2><p>由于我这里是用的chrome实现的自动化，所以我们先要下chrome的<a href="http://chromedriver.storage.googleapis.com/index.html" target="_blank" rel="noopener">启动器</a></p><p><img src="https://s2.ax1x.com/2019/06/08/VDNzdO.png" alt></p><p>我们需要下载对应版本的启动器，不然会失效，首先查看自己的chrome版本，然后打开每个版本的文件夹，里面有notes.txt,显示对应的支持版本范围。</p><p><img src="https://s2.ax1x.com/2019/06/08/VDU8O0.png" alt></p><p>下载好之后随便放到一个位置，后面根据路径引入即可，为了方便我将程序放到我的resource目录下了，如上图所示，代码如下：</p><pre><code class="java">        // 设置webdirver路径  这个BrushTicket是指的这个代码所在的类。        System.setProperty(&quot;webdriver.chrome.driver&quot;, BrushTicket.class.getClassLoader().getResource(&quot;chromedriver.exe&quot;).getPath());// 创建ChromeOptions，options可以设置一些网页请求头啥的        ChromeOptions options = new ChromeOptions();        //        指定本机chrome安装位置        options.setBinary(&quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot;);          // 创建WebDriver对象         ChromeDriver driver = new ChromeDriver(options);         // 打开那个网站         driver.get(&quot;https://www.wjx.cn/m/36384473.aspx&quot;);</code></pre><p>要记住，这个driver是最核心的类，我们后面根据这个driver在网页上做各种操作</p><h2 id="网页自动点击操作"><a href="#网页自动点击操作" class="headerlink" title="网页自动点击操作"></a>网页自动点击操作</h2><p>这个做法很简单，基本就是定位需要点击的位置，然后点击。</p><p>我截取了一小段代码，基本上所有点击的功能就都会了</p><pre><code class="java"> driver.findElement(By.xpath(&quot;//div[@id=&#39;divSubmit&#39;]/div[2]&quot;)).click();</code></pre><p>嗯哼，这里其实就需要注意一下这个xpath的定位问题，//div[@id=’xxx’],就是定位这个id为啥的元素，其实也可以用通配符，比如说 //* [@id=’xxx’]。后面再像洋葱一样，一层层的扒网页就行。</p><p>这个findElement的返回值是WebElement,这个元素又可以做各种操作，比如取css的属性，或者自己的属性，也可以点击和输入值(sendKeys)</p><h2 id="验证码-未完全解决"><a href="#验证码-未完全解决" class="headerlink" title="验证码(未完全解决)"></a>验证码(未完全解决)</h2><p>本来以为点完各种按钮，提交之后就完事，结果不！突然出现了验证码。</p><p>挣扎了很久，我选择了将验证码下载到本地后，然后解析出验证码这个解决办法。</p><h3 id="解决弹窗问题"><a href="#解决弹窗问题" class="headerlink" title="解决弹窗问题"></a>解决弹窗问题</h3><p>我们没有管验证码直接提交，会弹出一个警告框，我们先解决弹窗，后来发现问卷星的网页结构是，弹窗由一个div构成的，如果没有弹过的时候是没有这个结构的，第二次弹出之前，会将之前的div由display:none属性改回block属性，这样就简单了。具体代码如下：</p><pre><code class="java">/**    * 功能描述: //判断是否由弹出框    * @Param: [driver]    * @Return: boolean    * @Author: WHOAMI    * @Date: 2019/6/8 22:21     */private boolean ifAlert(ChromeDriver driver){       try       {         //定位元素，如果没有这个元素直接报错           WebElement  webElement = driver.findElement(By.xpath(&quot;//div[@id=&#39;alert_box&#39;]&quot;));           Thread.sleep(300);           if(!webElement.getCssValue(&quot;display&quot;).equals(&quot;none&quot;)) {               return true;           }       }       catch (Exception Ex)       {           Ex.printStackTrace();           return false;       }       return false;   }</code></pre><p>根据有没有Alert框判断是不是让我们输入验证码。</p><h3 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h3><p>首先我们需要利用Action解决右键另存图片这个操作</p><p>具体代码如下：</p><pre><code class="java">  // 这个driver是ChromeDriver      Actions action = new Actions(driver);// 定位到验证码图片的位置      WebElement element = driver.findElement(By.xpath(&quot;//div[@id=&#39;tdCode&#39;]/table/tbody/tr/td[3]/img&quot;));// action移动到指定位置      action.moveToElement(element);// 休眠等待网页反应      Thread.sleep(200);// 这里模拟右键 打开菜单      action.contextClick(element).build().perform();      //模拟键盘操作（这里是移动向下方向键）  这个Robot是java.awt包下面的      Robot robot = new Robot();      Thread.sleep(400);      // 模拟键盘下方向键      robot.keyPress(KeyEvent.VK_DOWN);      Thread.sleep(400);      robot.keyPress(KeyEvent.VK_DOWN);// 模拟回车键      Thread.sleep(400);      robot.keyPress(KeyEvent.VK_ENTER);</code></pre><p><strong>后面需要了解一下java.awt这个包</strong></p><p>由于后面的选择保存位置然后下载操作是selenium3实现不了的，所以我们选择了AUTolt这个软件，<a href="https://www.autoitscript.com/site/autoit/downloads/" target="_blank" rel="noopener">下载网址</a><br>,然后安装即可，这里不再赘述。</p><p>软件安装好之后，是这个样子的</p><p><img src="https://s2.ax1x.com/2019/06/08/VDcYiq.png" alt></p><h4 id="操作AUTolt定位窗口"><a href="#操作AUTolt定位窗口" class="headerlink" title="操作AUTolt定位窗口"></a>操作AUTolt定位窗口</h4><p>先打开游览器准备上面另存为的操作<br><img src="https://s2.ax1x.com/2019/06/08/VDgCYq.png" alt></p><p>定位另存为窗口需要这个数据 Class: 比如上面的窗口时#32770，下面写脚本需要用。</p><p><img src="https://s2.ax1x.com/2019/06/08/VDgklT.png" alt></p><p>定位按钮啊，编辑框啥的需要这个数据 CLassNameNN</p><p><img src="https://s2.ax1x.com/2019/06/08/VDge0J.png" alt></p><blockquote><p>其实我这里为了方便保存图片都是一个名字，而且为了方便都没有删除图片，所以这里出现了一个替换的问题，解决办法其实就是在定位一下替换的窗口和确定按钮就行</p></blockquote><h4 id="写脚本"><a href="#写脚本" class="headerlink" title="写脚本"></a>写脚本</h4><p>打开写脚本的工具，我的代码是这样的，改改就能用</p><pre><code class="bash">ControlFocus(&quot;另存为&quot;, &quot;&quot;,&quot;Edit1&quot;);ControlFocus(&quot;title&quot;,&quot;text&quot;,controlID) Edit1=Edit instance 1; Wait 10 seconds for the Upload window to appearWinWait(&quot;[CLASS:#32770]&quot;,&quot;&quot;,10); Set input focus to the edit control of Upload window using the handle returned by WinWait  ControlFocus(&quot;另存为&quot;,&quot;&quot;,&quot;Edit1&quot;)  Sleep(1000); Set the File name text on the Edit field  ControlSetText(&quot;另存为&quot;, &quot;&quot;, &quot;Edit1&quot;, &quot;buff.gif&quot;)  Sleep(200); Click on the Open buttonControlClick(&quot;另存为&quot;, &quot;&quot;,&quot;Button2&quot;);ControlFocus(&quot;确认另存为&quot;, &quot;&quot;,&quot;Edit2&quot;) WinWait(&quot;[CLASS:#32770]&quot;,&quot;&quot;,10) sleep(200)ControlClick(&quot;确认&quot;, &quot;&quot;,&quot;Button1&quot;);</code></pre><p>写完脚本后，保存成au3格式的文件，准备合成exe</p><h4 id="合成exe文件"><a href="#合成exe文件" class="headerlink" title="合成exe文件"></a>合成exe文件</h4><p>打开合成exe程序,确定脚本和生成exe路径即可。</p><p><img src="https://s2.ax1x.com/2019/06/08/VDg2As.png" alt></p><h4 id="java引用该文件"><a href="#java引用该文件" class="headerlink" title="java引用该文件"></a>java引用该文件</h4><pre><code class="java">//调用你使用Compile Script to.exe生成的可执行exe文件 这个download.exe就是我生成的exe文件           //对Windows窗体进行操作：更换文件名，并保存到指定文件夹     Runtime.getRuntime().exec(&quot;D:\\code\\java\\download.exe&quot;);//代码等待程序完成在进行接下来的操作。     Thread.sleep(4000);</code></pre><h3 id="验证码去除干扰线"><a href="#验证码去除干扰线" class="headerlink" title="验证码去除干扰线"></a>验证码去除干扰线</h3><p>由于我没有学<strong>openCV</strong>算法，所以我就直接粘代码了。</p><pre><code class="java">/**   * 功能描述: //验证码去除干扰线   * @Param: [sfile：图片文件路径, destDir：文件名字]   * @Return: void   * @Author: WHOAMI   * @Date: 2019/6/8 22:11    */   public static void cleanLinesInImage(File sfile, String destDir)  throws IOException {       File destF = new File(destDir);       if (!destF.exists())       {           destF.mkdirs();       }       BufferedImage bufferedImage = ImageIO.read(sfile);       int h = bufferedImage.getHeight();       int w = bufferedImage.getWidth();       // 灰度化       int[][] gray = new int[w][h];       for (int x = 0; x &lt; w; x++)       {           for (int y = 0; y &lt; h; y++)           {               int argb = bufferedImage.getRGB(x, y);               // 图像加亮（调整亮度识别率非常高）               int r = (int) (((argb &gt;&gt; 16) &amp; 0xFF) * 1.1 + 30);               int g = (int) (((argb &gt;&gt; 8) &amp; 0xFF) * 1.1 + 30);               int b = (int) (((argb &gt;&gt; 0) &amp; 0xFF) * 1.1 + 30);               if (r &gt;= 255)               {                   r = 255;               }               if (g &gt;= 255)               {                   g = 255;               }               if (b &gt;= 255)               {                   b = 255;               }               gray[x][y] = (int) Math                       .pow((Math.pow(r, 2.2) * 0.2973 + Math.pow(g, 2.2)                               * 0.6274 + Math.pow(b, 2.2) * 0.0753), 1 / 2.2);           }       }       // 二值化       int threshold = ostu(gray, w, h);       BufferedImage binaryBufferedImage = new BufferedImage(w, h, BufferedImage.TYPE_BYTE_BINARY);       for (int x = 0; x &lt; w; x++)       {           for (int y = 0; y &lt; h; y++)           {               if (gray[x][y] &gt; threshold)               {                   gray[x][y] |= 0x00FFFF;               } else               {                   gray[x][y] &amp;= 0xFF0000;               }               binaryBufferedImage.setRGB(x, y, gray[x][y]);           }       }       //去除干扰线条       for(int y = 1; y &lt; h-1; y++){           for(int x = 1; x &lt; w-1; x++){               boolean flag = false ;               if(isBlack(binaryBufferedImage.getRGB(x, y))){                   //左右均为空时，去掉此点                   if(isWhite(binaryBufferedImage.getRGB(x-1, y)) &amp;&amp; isWhite(binaryBufferedImage.getRGB(x+1, y))){                       flag = true;                   }                   //上下均为空时，去掉此点                   if(isWhite(binaryBufferedImage.getRGB(x, y+1)) &amp;&amp; isWhite(binaryBufferedImage.getRGB(x, y-1))){                       flag = true;                   }                   //斜上下为空时，去掉此点                   if(isWhite(binaryBufferedImage.getRGB(x-1, y+1)) &amp;&amp; isWhite(binaryBufferedImage.getRGB(x+1, y-1))){                       flag = true;                   }                   if(isWhite(binaryBufferedImage.getRGB(x+1, y+1)) &amp;&amp; isWhite(binaryBufferedImage.getRGB(x-1, y-1))){                       flag = true;                   }                   if(flag){                       binaryBufferedImage.setRGB(x,y,-1);                   }               }           }       }       // 矩阵打印       for (int y = 0; y &lt; h; y++)       {           for (int x = 0; x &lt; w; x++)           {               if (isBlack(binaryBufferedImage.getRGB(x, y)))               {                   System.out.print(&quot;*&quot;);               } else               {                   System.out.print(&quot; &quot;);               }           }           System.out.println();       }       ImageIO.write(binaryBufferedImage, &quot;jpg&quot;, new File(destDir, sfile               .getName()));   }   public static boolean isBlack(int colorInt)   {       Color color = new Color(colorInt);       if (color.getRed() + color.getGreen() + color.getBlue() &lt;= 300)       {           return true;       }       return false;   }   public static boolean isWhite(int colorInt)   {       Color color = new Color(colorInt);       if (color.getRed() + color.getGreen() + color.getBlue() &gt; 300)       {           return true;       }       return false;   }   public static int isBlackOrWhite(int colorInt)   {       if (getColorBright(colorInt) &lt; 30 || getColorBright(colorInt) &gt; 730)       {           return 1;       }       return 0;   }   public static int getColorBright(int colorInt)   {       Color color = new Color(colorInt);       return color.getRed() + color.getGreen() + color.getBlue();   }   public static int ostu(int[][] gray, int w, int h)   {       int[] histData = new int[w * h];       // Calculate histogram       for (int x = 0; x &lt; w; x++)       {           for (int y = 0; y &lt; h; y++)           {               int red = 0xFF &amp; gray[x][y];               histData[red]++;           }       }       // Total number of pixels       int total = w * h;       float sum = 0;       for (int t = 0; t &lt; 256; t++)           sum += t * histData[t];       float sumB = 0;       int wB = 0;       int wF = 0;       float varMax = 0;       int threshold = 0;       for (int t = 0; t &lt; 256; t++)       {           wB += histData[t]; // Weight Background           if (wB == 0)               continue;           wF = total - wB; // Weight Foreground           if (wF == 0)               break;           sumB += (float) (t * histData[t]);           float mB = sumB / wB; // Mean Background           float mF = (sum - sumB) / wF; // Mean Foreground           // Calculate Between Class Variance           float varBetween = (float) wB * (float) wF * (mB - mF) * (mB - mF);           // Check if new maximum found           if (varBetween &gt; varMax)           {               varMax = varBetween;               threshold = t;           }       }       return threshold;   }</code></pre><p>粘贴完代码后运行就会在相同的路径下覆盖原来的验证码图片，但是据我测试，这个代码效果不是很理想，所以才是未完成的操作。</p><h2 id="图像识别"><a href="#图像识别" class="headerlink" title="图像识别"></a>图像识别</h2><p>图片识别我打算利用tess4j。</p><p>maven导入项目</p><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;net.sourceforge.tess4j&lt;/groupId&gt;            &lt;artifactId&gt;tess4j&lt;/artifactId&gt;            &lt;version&gt;4.3.1&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>导入语言包，这一步操作需要我们下载tess4j的源代码，然后解压之后将tessdata移出来，供下面导入。</p><p>接着我们利用tess4j进行图像识别</p><p>我发现根据上面图像处理之后，图像放大10倍后tess4j的识别率是最高的，所以有了下面的代码</p><pre><code class="java">  /**  * 功能描述: //将代码放大10倍  * @Param: [file]  * @Return: java.awt.image.BufferedImage  * @Author: WHOAMI  * @Date: 2019/6/8 22:24   */    private static BufferedImage change(File file){        // 读取图片字节数组        BufferedImage textImage = null;        try{            InputStream in = new FileInputStream(file);            BufferedImage image = ImageIO.read(in);            in.close();            textImage = ImageHelper.convertImageToGrayscale(ImageHelper.getSubImage(image, 0, 0, image.getWidth(), image.getHeight()));  //对图片进行处理            textImage = ImageHelper.getScaledInstance(image, image.getWidth() * 10, image.getHeight() * 10);  //将图片扩大5倍        }catch (IOException e) {            e.printStackTrace();        }        return textImage;    }</code></pre><blockquote><p>接着就是我们的核心代码了</p></blockquote><pre><code class="java">public static String deal(String pathname,String fileName){        //打开需要处理的图片        File imageFile = new File(pathname+&quot;\\&quot;+fileName);        try {          //去干扰线            cleanLinesInImage(imageFile,pathname);        } catch (IOException e) {            e.printStackTrace();        }        //开始图像识别        Tesseract instance = new Tesseract();          // 这是我的语言包的路径        instance.setDatapath(&quot;D:\\code\\java\\ChromeOperation\\tessdata&quot;);        instance.setLanguage(&quot;eng&quot;);//选择字库文件（只需要文件名，不需要后缀名）        //将验证码图片的内容识别为字符串        try {          // 打开处理后的图像            File image = new File(pathname+&quot;\\&quot;+fileName);            String result = instance.doOCR(change(image));          //利用正则表达式过滤掉非法字符            String correct = result.replaceAll(&quot;[^0-9a-zA-Z]J*&quot;,&quot;&quot;);            // 返回正确的字符串            return correct;        } catch (TesseractException e) {            e.printStackTrace();        }        return null;    }</code></pre><h3 id="重复验证"><a href="#重复验证" class="headerlink" title="重复验证"></a>重复验证</h3><p>由于上面的代码并不理想，所以我打算利用死循环直到他输入正确为止，代码如下：</p><pre><code class="java">          while(ifAlert(driver)){               driver.findElement(By.xpath(&quot;//div[@id=&#39;alert_box&#39;]/div[2]/div[2]/div[2]&quot;)).click();               dealImg(driver);           }</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> selenium </tag>
            
            <tag> 自动化 </tag>
            
            <tag> orc </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java自定义注解</title>
      <link href="/2019/06/04/java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/06/04/java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="java自定义注解"><a href="#java自定义注解" class="headerlink" title="java自定义注解"></a>java自定义注解</h1><hr><p>这次的文章是我在上次文章的AOP文章遇到一个坑，通过joinPoint得到签名后，获得到他的注解为空，后来发现自己没有加相应的注解，这里记录此次的坑。</p><p>首先我们看一下正确的注释代码</p><pre><code class="java">@Target(ElementType.METHOD)@Documented@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface Cache {    boolean ifDelete() default false;}</code></pre><p>上次我们的文章的中本来是没有@Target等注解的，但是后来发现，这几个注解的作用是非常大的。</p><h2 id="每个注解的作用"><a href="#每个注解的作用" class="headerlink" title="每个注解的作用"></a>每个注解的作用</h2><p><strong>@Documented</strong></p><p>这个注解的作用就是，在生成javadoc文档的时候，将用过这个这个注解的方法的文档里面也写上这个注解。</p><p><strong>@Retention(Retention.RUNTIME)</strong></p><p>这个注解的作用在我看来就是在编译java代码的时候将这个注解也加上，也就是为什么不加这个注解，我们利用getAnnotation()这个方法等到的注解为null了。</p><p><strong>Target()</strong></p><p>这个注解是我们这个注解是为谁服务的，比如我们上面写的ElementType.METHOD,就是决定我们是为了方法服务的，如果写在类上面，这个注解会失效。</p><p>ElementType后面还有其他类别:</p><ul><li>ANNOTATION_TYPE 注解类型声明</li><li>CONSTRUCTOR 构造方法声明</li><li>FIELD 字段声明（包括枚举常量）</li><li>LOCAL_VARIABLE 局部变量声明</li><li>METHOD 方法声明</li><li>PACKAGE 包声明</li><li>PARAMETER 参数声明</li><li>TYPE 类、接口（包括注解类型）或枚举声明</li><li>TYPE_PARAMETER @since 1.8</li><li>TYPE_USE @since 1.8</li></ul><p><strong>@Inherited</strong><br>这个注解表示，打上这个注解之后，这个类如果被其他类继承后，子类会自动打上这个注解。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot中aop的尝试</title>
      <link href="/2019/06/03/springboot%E4%B8%ADaop%E7%9A%84%E5%B0%9D%E8%AF%95/"/>
      <url>/2019/06/03/springboot%E4%B8%ADaop%E7%9A%84%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot中对AOP技术的了解和使用"><a href="#springboot中对AOP技术的了解和使用" class="headerlink" title="springboot中对AOP技术的了解和使用"></a>springboot中对AOP技术的了解和使用</h1><p>我们在项目中如果使用spring的框架的话，aop技术多多少少也接触过，所以打算在这里总结一下AOP的技术核心和常用方法。</p><a id="more"></a><h2 id="AOP的基本使用方法-–-gt-全局AOP监听"><a href="#AOP的基本使用方法-–-gt-全局AOP监听" class="headerlink" title="AOP的基本使用方法 –&gt; 全局AOP监听"></a>AOP的基本使用方法 –&gt; 全局AOP监听</h2><p>我们现在要在Controller层做一个监听，每次进入controller的方法的时候，都启动AOP进行方法检查等操作。</p><p>接下来我们看一下源代码：</p><p>Controller层：</p><pre><code class="java">@RestControllerpublic class PageController {  //这个类在com.demo.controller包下@RequestMapping(&quot;/hello&quot;)   public Map&lt;String,String&gt; helloWorld(){       Map&lt;String,String &gt; map = new HashMap&lt;&gt;();       System.out.println(&quot;代码执行中&quot;);       map.put(&quot;hello&quot;,&quot;world&quot;);       System.out.println(&quot;继续执行&quot;);       return map;   }}</code></pre><p>AOP：</p><pre><code class="java">/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019 2019/6/2 16:06 * Description: ://TODO ${END} */@Slf4j@Aspect@Componentpublic class WebLogAspect { @Pointcut(&quot;execution(public * com.demo.controller.*.*(..))&quot;)    private void weblog(){}    @Before(&quot;weblog()&quot;)    private void doBefore(JoinPoint joinPoint) throws Throwable {        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        log.info(&quot;URL: &quot;+request.getRequestURL().toString());        log.info(&quot;Method&quot; + request.getMethod());        log.info(&quot;HTTP_METHOD: &quot;+request.getMethod());        log.info(&quot;IP: &quot;+request.getRemoteAddr());        Enumeration&lt;String&gt; enu = request.getParameterNames();        while (enu.hasMoreElements()) {            String name = enu.nextElement();            log.info(&quot;name:{},value:{}&quot;, name, request.getParameter(name));        }    }    @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;weblog()&quot;)    public void doAfterReturning(Object ret) throws Throwable {        log.info(&quot;RESPONSE: &quot; + ret);    }}</code></pre><ul><li>下面讲解一下这个AOP的常用技术</li></ul><p><strong>@Aspect</strong><br>标记这是一个切面，如果没有这个注解，那么这个方法不启动</p><p><strong>Pointcut</strong><br>切点，后面的execution是决定监听哪里的方法</p><p><strong>Befoe</strong><br>前置通知</p><p><strong>After</strong><br>后置通知</p><h2 id="下面是我常用的AOP方法"><a href="#下面是我常用的AOP方法" class="headerlink" title="下面是我常用的AOP方法"></a>下面是我常用的AOP方法</h2><p>利用自定义注解决定切点</p><p>下面我们自定义一个注解</p><pre><code class="java">@Target(ElementType.METHOD)@Documented@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface Cache {  boolean ifDelete() default false;}</code></pre><p>在我们的Controller层方法上加入这个注解</p><pre><code class="java">@RequestMapping(&quot;/hello&quot;)   @Cache(ifDelete = true)   public Map&lt;String,String&gt; helloWorld(){       Map&lt;String,String &gt; map = new HashMap&lt;&gt;();       System.out.println(&quot;代码执行中&quot;);       map.put(&quot;hello&quot;,&quot;world&quot;);       System.out.println(&quot;继续执行&quot;);       return map;   }</code></pre><p>AOP层：</p><pre><code class="java">@Slf4j@Aspect@Componentpublic class TestAsp {    @Around(&quot;@annotation(com.demo.flag.Cache)&quot;)    public Object testJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable {        System.out.println(&quot;进入aop&quot;);        return joinPoint.proceed();        System.out.println(&quot;代码执行aop后&quot;);    }}</code></pre><p>我们访问一下这个地址，结果是这个样子的</p><pre><code class="bash">&gt;进入aop&gt;代码执行中&gt;继续执行&gt;代码执行aop后</code></pre><p>这里不需要PointCut，而是利用@annotation将所有有上面这个注解的方法都会进入这个AOP方法。</p><p>其实这个@Around是一个环绕通知，你可以在这里通过jionPoint获得到访问者IP，变量参数等等。</p><p>这个joinPoint.proceed()方法是让controller方法的必要条件。</p><p>joinPoint.proceed()方法后的代码是处理完方法后需要执行的代码，这样就可以想象成这个Around将controller层的某个方法’包裹’起来了。</p><h2 id="JoinPoint的常用方法"><a href="#JoinPoint的常用方法" class="headerlink" title="JoinPoint的常用方法"></a>JoinPoint的常用方法</h2><ul><li><p>获取到方法的注解</p><pre><code class="java">MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();      Cache annotation = methodSignature.getMethod().getAnnotation(Cache.class);</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8中Optional的使用</title>
      <link href="/2019/06/02/java8%E4%B8%ADOptional%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/06/02/java8%E4%B8%ADOptional%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="java8中Optional的使用"><a href="#java8中Optional的使用" class="headerlink" title="java8中Optional的使用"></a>java8中Optional的使用</h1><hr><p>我们在之前的业务开发中，有时候会遇到搜查结果为空的情况，但是返回Null的时候，我们就必须要判断一下是否为null,如果是的话要么throw一个异常或者别的什么操作，例如账号登陆失败的时候。</p><p>这样显得代码非常臃肿，而java8得Optional完美解决了这个问题(主要是空指针问题)。</p><h2 id="创建一个Optional实例"><a href="#创建一个Optional实例" class="headerlink" title="创建一个Optional实例"></a>创建一个Optional实例</h2><pre><code class="java">Optional&lt;String&gt; name2 = Optional.empty();Optional&lt;String&gt; name = Optional.ofNullable(null);Optional&lt;String&gt; name3 = Optional.of(&quot;111&quot;);</code></pre><p>这三个其实区别就是 第一个只是创建一个Optional实例，相当于Null。第二个允许传入一个Null的对象，如果用第三个Optional.of(null)的话，直接会爆出空指针异常。</p><h2 id="获取Optional的值"><a href="#获取Optional的值" class="headerlink" title="获取Optional的值"></a>获取Optional的值</h2><pre><code class="java">User user = new User(&quot;john@gmail.com&quot;,&quot;1234&quot;);User user2 = new User(&quot;anna@gmail.com&quot;, &quot;1234&quot;);User result = Optional.ofNullable(user).orElse(new User);User result2 = Optional.of(user).orElseGet(() -&gt; new User);User result3 = Optional.ofNullable(user)                .orElseThrow(() -&gt; new RuntimeExcetion(&quot;运行出错了&quot;));User result4 = Optional.ofNullable(user).Get();</code></pre><p>下面来讲一下这几个方法的异同</p><p>orElse:有值就返回值，不管有没有值都会执行后面的操作(new 一个对象等等)，如果没有值才会返回结果。</p><p>orElseGet:有值就返回值，没有值才进行后面的表达式操作</p><blockquote><p>如果传入的值都是Null的情况下，两个函数没有区别，但是不是空的情况下，orElseGet显然效率比较高</p></blockquote><p>orElseThrow:有值就返回值,没有值抛用户定义的异常</p><p>Get:有值就返回值,没有值NoSuchElementException。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE基础知识点</title>
      <link href="/2019/05/24/javaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2019/05/24/javaSE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="javaSE基础知识点汇总"><a href="#javaSE基础知识点汇总" class="headerlink" title="javaSE基础知识点汇总"></a>javaSE基础知识点汇总</h1><hr><h2 id="final关键字的理解"><a href="#final关键字的理解" class="headerlink" title="final关键字的理解"></a>final关键字的理解</h2><p>final如果赋给了变量，证明这个变量是不能修改的<br>但是，要注意，如果给数组附上了final关键字，他的数组元素是可以修改的</p><p>例如：</p><pre><code class="java">public static void main(String args[]){        final  int b[] = {5};        int a[] = {3};        b[0] = 2;        // b = a;  编译错误，因为是final类型        System.out.println(b[0]);    }</code></pre><h2 id="equals-和-之间的区别"><a href="#equals-和-之间的区别" class="headerlink" title="equals 和 == 之间的区别"></a>equals 和 == 之间的区别</h2><p>== 是直接比较地址，一般用来比较8大基本数据类型</p><p>equals则是一般由开发人员复写的，但是如果默认，则会比较他们的值是否一致，equals的源代码是：</p><pre><code class="java">public boolean equals(Object obj) {    return (this == obj);}</code></pre><blockquote><p>但是需要注意一点的是 java中对String的equals写法是这样的,他复写了原始的方法</p></blockquote><pre><code class="java">@Overridepublic boolean equals(Object anObject) {    if (this == anObject) {        return true;    }    if (anObject instanceof String) {        String anotherString = (String)anObject;        int n = count;        if (n == anotherString.count) {            char v1[] = value;            char v2[] = anotherString.value;            int i = offset;            int j = anotherString.offset;            while (n-- != 0) {                if (v1[i++] != v2[j++])                    return false;            }            return true;        }    }    return false;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java.io知识点整理</title>
      <link href="/2019/05/23/java-io%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2019/05/23/java-io%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="java-io-流的一些知识点整理"><a href="#java-io-流的一些知识点整理" class="headerlink" title="java io 流的一些知识点整理"></a>java io 流的一些知识点整理</h1><hr><h2 id="java流类图总结"><a href="#java流类图总结" class="headerlink" title="java流类图总结"></a>java流类图总结</h2><p><img src="https://s2.ax1x.com/2019/05/23/VPsDmt.png" alt></p><a id="more"></a><h2 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h2><p>字节流处理的是二进制文件，也就是说,二进制文件什么也能处理，比如文字和图片视频什么的。<br>而字符流则只能处理文本类型，但是它可以处理编码问题，例如我们的字节流读取出来的文件是乱码的，就是因为文件的编码问题。</p><blockquote><p>下面是一个读取中文文本的样例。</p></blockquote><pre><code class="java">public static void main(String args[]){        int b; //这里的默认值是0        try {          //这里的f变量是为了后面建立char[]数组读取文件大小            File f = new File(&quot;D:\\\\test.txt&quot;);            //创建字符流            InputStreamReader isr = new InputStreamReader(new FileInputStream(f),&quot;GBK&quot;);            //建立buf ,注意，如果文件中有中文的话，这里的buf里面会多建立空间，因为中文占两个字节空间            char[] buf = new char[(int) f.length()];            int len = isr.read(buf);            String rs = new String(buf,0,len);            isr.close();        }        catch (Exception e) {            System.out.println(&quot;出错了，原因是：&quot;);            System.out.println (e.toString());        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javaSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ps改变图片特定颜色</title>
      <link href="/2019/05/18/ps%E6%94%B9%E5%8F%98%E5%9B%BE%E7%89%87%E7%89%B9%E5%AE%9A%E9%A2%9C%E8%89%B2/"/>
      <url>/2019/05/18/ps%E6%94%B9%E5%8F%98%E5%9B%BE%E7%89%87%E7%89%B9%E5%AE%9A%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="ps改变图片特定颜色"><a href="#ps改变图片特定颜色" class="headerlink" title="ps改变图片特定颜色"></a>ps改变图片特定颜色</h1><hr><blockquote><p>首先我们看一下我们的原图片，对没错是看门狗的图片</p></blockquote><p><img src="https://s2.ax1x.com/2019/05/18/EOM6B9.jpg" alt></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>现在我们需要吧这个图片修改一下：</p><ul><li>删除图片上面的白边</li><li>将背景色换成透明</li><li>将中间白色logo变成黑色</li><li>改变图片分辨率为200*200</li></ul><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><ol><li>打开ps后Ctrl+j 复制图层，将背景预览关掉</li><li>删除白边的话，这里不再叙述</li><li>由于我们这张图片色差明显，所以我们采用魔棒工具，将背景点选，然后Del删除，现在情况是这样的<br> <img src="https://s2.ax1x.com/2019/05/18/EOMxgS.png" alt></li><li>现在我们需要将图片上的黑色变成别的颜色作为一个temp,之后将白色主体部分变成黑色之后，可以将temp部分变成黑色或者其他颜色</li><li>选择菜单栏 –&gt; 选择 –&gt; 色彩范围 弹出色彩范围的框里面按下图操作<br> <img src="https://s2.ax1x.com/2019/05/18/EOQiEn.png" alt><br> 选择黑色部分，然后确定，之后图片会将那些图片框住</li><li>按ctrl+ u 弹出色相和饱和度框 勾选着色 选择合适的颜色后确认<br> <img src="https://s2.ax1x.com/2019/05/18/EOQ14x.png" alt></li><li>重复上面操作将白色主体部分变成黑色<br><img src="https://s2.ax1x.com/2019/05/18/EOQNKe.png" alt></li><li>选择菜单 -&gt; 图像 -&gt; 图像大小 改变宽度和高度</li><li>导出图片 完工！</li></ol>]]></content>
      
      
      <categories>
          
          <category> Photoshop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photoshop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 利用触发器来实现check约束</title>
      <link href="/2019/05/17/mysql-%E5%88%A9%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0check%E7%BA%A6%E6%9D%9F/"/>
      <url>/2019/05/17/mysql-%E5%88%A9%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0check%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-利用触发器来实现check约束"><a href="#mysql-利用触发器来实现check约束" class="headerlink" title="mysql 利用触发器来实现check约束"></a>mysql 利用触发器来实现check约束</h1><hr><p>由于我用的是mysql5.6.34版本，所以据我的了解来看，mysql对于check约束还是一个摆设。</p><p>但是我们可以利用触发器(trigger)来实现一种类check约束</p><p>下面我们来一个实例：</p><hr><p>我们需要创建一个学生表 sno 主键，sage 年龄在16-20之内</p><p>这个sage就是一个check约束</p><p>首先我们创建我们的studen表</p><pre><code>CREATE TABLE Student (    Sno VARCHAR(3) PRIMARY KEY,    Sage INT ,)ENGINE=INNODB DEFAULT CHARSET=utf8;</code></pre><p>接着我们创建触发器</p><pre><code># 这个是在插入insert之前触发 指定是在student表CREATE TRIGGER test_student_insert_check BEFORE INSERTON Student FOR EACH ROWBEGIN    DECLARE msg varchar(100);    IF NEW.Sage &lt;= 16 OR NEW.Sage &gt;= 20     THEN        SET msg = CONCAT(&#39;无效的年龄!&#39;);        SIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT = msg;    END IF;END;</code></pre><blockquote><p>注意，虽然这样可以做到check的效果，但是还是非常不建议用触发器，因为太慢了，所以我们最好还是在插入之前判断，例如spring的service层。</p></blockquote><blockquote><p>而且，这个插入只是管理insert插入的，更新的话还是不会拦截的，而且我们又不可能在创建一个update触发器，太浪费资源，所以这个博文只是一种思想，并不实用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql使用心得</title>
      <link href="/2019/05/13/mysql%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
      <url>/2019/05/13/mysql%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql使用心得"><a href="#mysql使用心得" class="headerlink" title="mysql使用心得"></a>mysql使用心得</h1><ul><li>对于那种datetime属性的默认值 可以写CURRENT_TIMESTAMP，来填充当前时间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mariadb做读写分离</title>
      <link href="/2019/05/13/mariadb%E5%81%9A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2019/05/13/mariadb%E5%81%9A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="mariadb读写分离"><a href="#mariadb读写分离" class="headerlink" title="mariadb读写分离"></a>mariadb读写分离</h1><p>上一次文章我在centos7上安装了mariadb并开启了主从复制模式，这一篇打算利用mycat做读写分离</p><p>mycat现在可以相称像是nginx一样的反向代理，他可以不暴露数据库的ip</p><p>环境：</p><table><thead><tr><th>IP地址</th><th>作用</th></tr></thead><tbody><tr><td>192.168.3.137</td><td>mycat服务器，主数据库</td></tr><tr><td>192.168.3.136</td><td>从数据库</td></tr></tbody></table><h2 id="安装mycat"><a href="#安装mycat" class="headerlink" title="安装mycat"></a>安装mycat</h2><hr><ul><li><p>打开mycat<a href="http://www.mycat.io/" target="_blank" rel="noopener">官网</a>,选择版本下载，我这里是1.6.6</p></li><li><p>将tar包解压到centos下的/usr/local/下</p></li></ul><pre><code>添加环境变量vi /etc/profileexport MYCAT_HOME=/usr/local/mycat# 退出source /etc/profile #使之生效cd /usr/local/mycat/bin./mycat start #启动./mycat status #查看是否启动</code></pre><p><img src="https://s2.ax1x.com/2019/05/13/E4b7VA.png" alt></p><p>一般没什么问题</p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><hr><p>首先备份一下两个重要文件，如果弄坏了还可以还原</p><pre><code>cd /usr/local/mycat/confcp ./server.xml ./server.xml.bakcp ./schema.xml ./schema.xml.bak</code></pre><p>配置用户供远程登陆 <strong>server.xml</strong></p><pre><code>vi /usr/local/conf/server.xml </code></pre><p><img src="https://s2.ax1x.com/2019/05/13/E4qP5q.png" alt></p><p>拉到最后，修改里面的用户就行了</p><p>配置需要管理的表 <strong>schema.xml</strong></p><p><img src="https://s2.ax1x.com/2019/05/13/E4LkTA.png" alt></p><h2 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h2><hr><p>重启一下mycat,查看一下状态是否运行</p><pre><code>./mycat restart./mycat status</code></pre><p>打开window上的navicat 选择连接 注意 这里一定是mysql 不然会报错</p><blockquote><p>注意 mycat的默认端口是8066</p></blockquote><p><img src="https://s2.ax1x.com/2019/05/13/E4Llwj.png" alt></p><p>交易成功！</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7 安装mariadb 并配置主从复制</title>
      <link href="/2019/05/12/centos7%E4%B8%8B%E5%AE%89%E8%A3%85mariadb%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2019/05/12/centos7%E4%B8%8B%E5%AE%89%E8%A3%85mariadb%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="centos7下安装mariadb"><a href="#centos7下安装mariadb" class="headerlink" title="centos7下安装mariadb"></a>centos7下安装mariadb</h1><h2 id="卸载已经存在的mariadb"><a href="#卸载已经存在的mariadb" class="headerlink" title="卸载已经存在的mariadb"></a>卸载已经存在的mariadb</h2><hr><p>检查是否已经安装mariadb</p><pre><code>rpm -qa|grep mariadb</code></pre><p>如果存在先卸载掉</p><pre><code>rpm -e --nodeps xxxx</code></pre><a id="more"></a><h2 id="安装mariadb"><a href="#安装mariadb" class="headerlink" title="安装mariadb"></a>安装mariadb</h2><hr><pre><code>yum -y install mariadb mariadb-server #安装systemctl start mariadb # 启动mariadb服务systemctl enable mariadb #设置开机启动</code></pre><h2 id="mariadb简单配置"><a href="#mariadb简单配置" class="headerlink" title="mariadb简单配置"></a>mariadb简单配置</h2><pre><code>mysql_secure_installation #开始简单配置首先是设置密码，会提示输入密码Enter current password for root (enter for none):  --&gt;初次设置直接回车Set root password? [Y/n] --&gt;y New password:Re-enter new password:其他设置Remove anonymous users? [Y/n] --&gt;是否删除匿名用户 回车Disallow root login remotely? [Y/n] --&gt;是否禁止远程用户 nRemove test database and access to it? [Y/n] --&gt;删除test数据库 回车Reload privilege tables now? [Y/n]  --&gt;是否重新加载权限表 回车</code></pre><h2 id="配置mariadb编码"><a href="#配置mariadb编码" class="headerlink" title="配置mariadb编码"></a>配置mariadb编码</h2><pre><code>vi /etc/my.cnf#在[mysqld]下面添加init_connect=&#39;SET collation_connection = utf_unicode_ci&#39;init_connect=&#39;SET NAMES utf8&#39;character-set-server=utf8collation-server=utf8_unicode_ciskip-character-set-client-handshakevi etc/my.cnf.d/clent.cnf# 在[client]下添加default-character-set=utf8vi etc/my.cnf.d/mysql-clients.cnf#在[mysqld]下添加default-character-set=utf8</code></pre><pre><code>配置完成 重启服务systemctl restart mariadb查看mariadb字符集show variables like &quot;%character%&#39;; show variables like &quot;%collation%&quot;;</code></pre><h2 id="添加外网用户"><a href="#添加外网用户" class="headerlink" title="添加外网用户"></a>添加外网用户</h2><hr><pre><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;IDENTIFIED BY &#39;123&#39; WITH GRANT OPTION; #配置用户并授权flush privileges; #刷新权限</code></pre><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="主服务器配置"><a href="#主服务器配置" class="headerlink" title="主服务器配置"></a>主服务器配置</h3><pre><code>vi /etc/my.conf # 添加下面两个字段server-id=137 #这个数字随便写log-bin=master-log #我尝试过放到另一个文件夹下，但是由于权限问题，始终启动错误，现在这个二进制文件是在你配置的datadir下面的innodb_file_per_table=on  #跳过主机名解析。在CentOS 6自带的mysql后面的=on不用写skip_name_resolve=on #innodb的每个表是用单独的文件</code></pre><p>启动服务</p><pre><code>systemctl start mariadb      #启动数据库GRANT REPLICATION SLAVE,REPLICATION CLIENT ON *.* TO &#39;guest&#39;@&#39;%&#39; IDENTIFIED BY &#39;123&#39;; #创建从服务器用来连接的账号FLUSH PRIVILEGES; #刷新服务器</code></pre><p>查询当前日志情况</p><pre><code>show master status;</code></pre><p>这两个参数供从服务器连接并复制</p><p><img src="https://s2.ax1x.com/2019/05/12/E4phUe.png" alt></p><h3 id="从服务器配置"><a href="#从服务器配置" class="headerlink" title="从服务器配置"></a>从服务器配置</h3><pre><code>server_id=2relay_log=relay-log         #启用中继日志。在数据目录下有一个relay-kog.info里面保存了当前的中继日志和位置会主节点二进制文件的名字和位置。read_only=on                #禁止用户写入数据，这一项的管理员和复制重放无效。</code></pre><p>启动服务</p><pre><code>mysql&gt; FLUSH TABLES WITH READ LOCK;     #添加全局读锁,只允许读mysql&gt; reset slave;mysql&gt; CHANGE MASTER TO MASTER_HOST=&#39;192.168.3.137&#39;,MASTER_USER=&#39;guest&#39;,MASTER_PASSWORD=&#39;123&#39;,MASTER_LOG_FILE=&#39;master-log.000003&#39;,MASTER_LOG_POS=245; #远程连接，将上文查出来的日志文件和位置填写在上面mysql&gt; START SLAVE; #开始线程</code></pre><pre><code>#查询启动情况mysql&gt; SHOW SLAVE STATUS\G;</code></pre><p><img src="https://s2.ax1x.com/2019/05/12/E4p7vt.png" alt></p><blockquote><p>启动成功!</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内存模型初窥探</title>
      <link href="/2019/05/12/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%88%9D%E7%AA%A5%E6%8E%A2/"/>
      <url>/2019/05/12/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%88%9D%E7%AA%A5%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java内存模型初探"><a href="#java内存模型初探" class="headerlink" title="java内存模型初探"></a>java内存模型初探</h1><p>jdk1.8以前的内存模型是这样的，</p><p><img src="https://s2.ax1x.com/2019/05/12/EhEDxJ.png" alt></p><p>下面我分析一下他们的作用</p><a id="more"></a><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区也叫永久区，一些类的信息：方法名 返回值什么的，常量，静态变量都放在里面，class文件加载</p><p>这是是线程共享的 她其实是放在堆中的永久代中的，但是这个永久代又和堆是隔离的</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img src="https://s2.ax1x.com/2019/05/12/EhELIf.png" alt></p><p>堆中存放的是new的对象，是jVM中最大的空间</p><p>这个是线程共享的</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><img src="https://s2.ax1x.com/2019/05/12/EhVpss.png" alt></p><p>这个是线程私有的 就是说，一个线程开一个虚拟机栈</p><p>我的理解是每当一个java方法运行的时候，就在当前的虚拟机栈压入一个新的栈帧，运行完之后，出栈</p><h2 id="本地虚拟栈"><a href="#本地虚拟栈" class="headerlink" title="本地虚拟栈"></a>本地虚拟栈</h2><p>本地虚拟栈和虚拟机栈差不多，但是他是为native服务的，我的理解是native是为别的语言服务的，比如java的底层C</p><p>当然也是线程私有</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>我的理解是字节码去执行代码的时候，程序计数器来告诉他们下一句代码是什么，当然也是私有的，每个线程一个程序计数器，来记录代码执行到哪里了。</p><h1 id="jdk1-8后的改版"><a href="#jdk1-8后的改版" class="headerlink" title="jdk1.8后的改版"></a>jdk1.8后的改版</h1><p><img src="https://s2.ax1x.com/2019/05/12/EhQaIs.png" alt></p><p>jdk1.8之后将方法区(永久区)去掉，变成了元数据区。他并没有在堆里面，而是直接在本地内存中。</p><p>堆也变成了这样</p><p><img src="https://s2.ax1x.com/2019/05/12/EhQysU.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的一些常用编程思想</title>
      <link href="/2019/05/09/java%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
      <url>/2019/05/09/java%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这一个文章单纯的是常见的一些编程思想的总结</p></blockquote><a id="more"></a><p><strong>让一个变量重复的 非零即一</strong></p><pre><code class="java">nt test = 1;test = test %2;</code></pre><p><strong>取三个数中间值</strong></p><pre><code class="java">if ((b - a) * (a - c) &gt;= 0) { //如果a是中间数的话 b-a 和 a-c一定是相反数            return a;} else if ((a - b) * (b - c) &gt;= 0) {        return b;} else {        return c;}</code></pre><p> <strong>循环队列</strong></p><pre><code class="java">//加入一个队列rear有固定的空间，我现在让他循环存储可以用取模算法rear = (rear +1)%MAX</code></pre><p><strong>数据库分表</strong></p><p>假如现在有非常多数据，需要让他们放到不同的表中，可以用到取模算法</p><p>比如  我们有三个表， 在我们知道需要插入的具体id的时候，id%3就是他要存的表。</p><p><strong>判断是否是奇数</strong></p><p>我们通常用的是取模算法，但是还有一种是位与算法</p><pre><code class="java">if(n&amp;1 == 1){    //n就是奇数}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt TCP UDP-多线程笔记</title>
      <link href="/2019/05/08/qt-TCP-UDP-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/05/08/qt-TCP-UDP-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="qt-TCP-UDP-多线程解决并发思路"><a href="#qt-TCP-UDP-多线程解决并发思路" class="headerlink" title="qt TCP UDP 多线程解决并发思路"></a>qt TCP UDP 多线程解决并发思路</h1><h2 id="TCP解决思路"><a href="#TCP解决思路" class="headerlink" title="TCP解决思路"></a>TCP解决思路</h2><hr><p>目的：每一个客户端连接都需要QTCPSocket开辟一条新的线程</p><p>解决方法：</p><ol><li><p>分别继承QTCPServer和QTCPSocket来分别实现Server和Socket（我这里是mTCPServer继承QTCPServer,mTCPSoket继承QTCPSokcet）</p></li><li><p>mTCPServer重写incomingConnection来实现socket的自动连接，其实就是不需要connect等待连接，直接进入函数</p><pre><code class="c++">protected: void incomingConnection(qintptr handle);</code></pre><p><img src="https://s2.ax1x.com/2019/05/09/Ecyj3Q.png" alt></p></li><li>重写incomingConnection()函数</li></ol><pre><code class="c++">void MyTcpServer::incomingConnection( qint32 socketDescriptor){    qDebug()&lt;&lt;tr(&quot;有新的连接 :-socketDescriptor-&quot;)&lt;&lt;socketDescriptor;    emit displayAccount(true); //这里是我给主界面发信号,有用户连接    MyTcpSocket *tcptemp = new MyTcpSocket(socketDescriptor);    //初始化线程    QThread *thread = new QThread(tcptemp);    //收到客户端发送的信息    connect(tcptemp,&amp;MyTcpSocket::receiveData,this,&amp;MyTcpServer::receiveDataSlot);    //客户端断开链接    connect(tcptemp,&amp;MyTcpSocket::socketDisconnect,this,&amp;MyTcpServer::disconnectSlot);    //客户端断开链接 关闭线程    connect(tcptemp,&amp;MyTcpSocket::disconnected,thread,&amp;QThread::quit);    //向socket发送信息    // 发送注册信息    connect(this,&amp;MyTcpServer::sendRegisterData,tcptemp,&amp;MyTcpSocket::sendRegisterData);    //将socket移动到子线程运行    tcptemp-&gt;moveToThread(thread);    thread-&gt;start();    //将Qthread放到Map控制    clients-&gt;insert(socketDescriptor,tcptemp);    qDebug()&lt;&lt;tr(&quot;目前客户端数量：&quot;)&lt;&lt;clients-&gt;size();}</code></pre><ol start="4"><li>mTCPSokcet解决相应的信号即可</li></ol><h2 id="多线程UDP解决思路"><a href="#多线程UDP解决思路" class="headerlink" title="多线程UDP解决思路"></a>多线程UDP解决思路</h2><hr><p>UDP的话就比较简单了,最核心的代码是这个</p><pre><code class="c++">/** * function:监听端口 * @brief MyUDPServer::startService */void MyUDPServer::startService(){    //这里监听端口    this-&gt;mUdpSocket = new QUdpSocket(this);    int error =this-&gt;mUdpSocket-&gt;bind(QHostAddress::Any,9999);    qDebug()&lt;&lt;error;    QObject::connect(mUdpSocket,SIGNAL(readyRead()),this,SLOT(readData()));}MyUDPServer::MyUDPServer(QObject *parent):QObject(parent){}/** * function: 多线程读取数据 * @brief MyUDPServer::readData */void MyUDPServer::readData(){    //获取到传来的数据    while(this-&gt;mUdpSocket-&gt;hasPendingDatagrams()){        //获取数据        QByteArray array;        QHostAddress address;        quint16 port;           //根据可读数据来设置空间大小        array.resize(this-&gt;mUdpSocket-&gt;pendingDatagramSize());        this-&gt;mUdpSocket-&gt;readDatagram(array.data(),array.size(),&amp;address,&amp;port); //读取数据        //创建线程        MsgAction *msgAction = new MsgAction(array,address,port);        QThread *thread = new QThread(msgAction);        //需要封装        qDebug()&lt;&lt;QThread::currentThread();        //移动到线程中        msgAction-&gt;moveToThread(thread);        thread-&gt;start();        msgAction-&gt;run();       //发送反馈数据    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
            <tag> TCP UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装fastDFS</title>
      <link href="/2019/05/03/centos7%E5%AE%89%E8%A3%85fastDFS/"/>
      <url>/2019/05/03/centos7%E5%AE%89%E8%A3%85fastDFS/</url>
      
        <content type="html"><![CDATA[<h1 id="centos7安装fastDFS"><a href="#centos7安装fastDFS" class="headerlink" title="centos7安装fastDFS"></a>centos7安装fastDFS</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><hr><h3 id="使用的系统软件"><a href="#使用的系统软件" class="headerlink" title="使用的系统软件"></a>使用的系统软件</h3><hr><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>centos</td><td>7.x</td></tr><tr><td>libfatscommon</td><td>FastDFS分离出的一些公用函数包</td></tr><tr><td>FastDFS</td><td>FastDFS本体</td></tr><tr><td>fastdfs-nginx-module</td><td>FastDFS和nginx的关联模块</td></tr><tr><td>nginx</td><td>nginx1.15.4</td></tr></tbody></table><h3 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h3><hr><pre><code>yum install git gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl-devel wget vim -y</code></pre><h3 id="磁盘目录"><a href="#磁盘目录" class="headerlink" title="磁盘目录"></a>磁盘目录</h3><hr><table><thead><tr><th>说明</th><th>位置</th></tr></thead><tbody><tr><td>所有安装包</td><td>/usr/local/src</td></tr><tr><td>数据存储位置</td><td>/home/dfs/</td></tr><tr><td>#这里我为了方便把日志什么的都放到了dfs</td></tr></tbody></table><pre><code>mkdir /home/dfs #创建数据存储目录cd /usr/local/src #切换到安装目录准备下载安装包</code></pre><h3 id="安装libfatscommon"><a href="#安装libfatscommon" class="headerlink" title="安装libfatscommon"></a>安装libfatscommon</h3><hr><pre><code>git clone https://github.com/happyfish100/libfastcommon.git --depth 1cd libfastcommon/./make.sh &amp;&amp; ./make.sh install #编译安装</code></pre><h3 id="安装FastDFS"><a href="#安装FastDFS" class="headerlink" title="安装FastDFS"></a>安装FastDFS</h3><hr><pre><code>cd ../ #返回上一级目录git clone https://github.com/happyfish100/fastdfs.git --depth 1cd fastdfs/./make.sh &amp;&amp; ./make.sh install #编译安装#配置文件准备cp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.confcp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.confcp /etc/fdfs/client.conf.sample /etc/fdfs/client.conf #客户端文件，测试用cp /usr/local/src/fastdfs/conf/http.conf /etc/fdfs/ #供nginx访问使用cp /usr/local/src/fastdfs/conf/mime.types /etc/fdfs/ #供nginx访问使用</code></pre><h3 id="安装fastdfs-nginx-module"><a href="#安装fastdfs-nginx-module" class="headerlink" title="安装fastdfs-nginx-module"></a>安装fastdfs-nginx-module</h3><hr><pre><code>cd ../ #返回上一级目录git clone https://github.com/happyfish100/fastdfs-nginx-module.git --depth 1cp /usr/local/src/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs</code></pre><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><hr><pre><code>wget http://nginx.org/download/nginx-1.15.4.tar.gz #下载nginx压缩包tar -zxvf nginx-1.15.4.tar.gz #解压cd nginx-1.15.4/#添加fastdfs-nginx-module模块./configure --add-module=/usr/local/src/fastdfs-nginx-module/src/ make &amp;&amp; make install #编译安装</code></pre><h2 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h2><hr><h3 id="tracker配置"><a href="#tracker配置" class="headerlink" title="tracker配置"></a>tracker配置</h3><hr><pre><code>#服务器ip为 192.168.52.1#我建议用ftp下载下来这些文件 本地修改vim /etc/fdfs/tracker.conf#需要修改的内容如下port=22122  # tracker服务器端口（默认22122,一般不修改）base_path=/home/dfs  # 存储日志和数据的根目录</code></pre><h3 id="storage配置"><a href="#storage配置" class="headerlink" title="storage配置"></a>storage配置</h3><hr><pre><code>vim /etc/fdfs/storage.conf#需要修改的内容如下port=23000  # storage服务端口（默认23000,一般不修改）base_path=/home/dfs  # 数据和日志文件存储根目录store_path0=/home/dfs  # 第一个存储目录tracker_server=192.168.52.1:22122  # tracker服务器IP和端口http.server_port=8888  # http访问文件的端口(默认8888,看情况修改,和nginx中保持一致)</code></pre><h3 id="client测试"><a href="#client测试" class="headerlink" title="client测试"></a>client测试</h3><hr><pre><code>vim /etc/fdfs/client.conf#需要修改的内容如下base_path=/home/dfstracker_server=192.168.52.1:22122    #tracker服务器IP和端口#保存后测试,返回ID表示成功 如：group1/M00/00/00/xx.tar.gzfdfs_upload_file /etc/fdfs/client.conf /usr/local/src/nginx-1.15.4.tar.gz</code></pre><h3 id="配置nginx访问"><a href="#配置nginx访问" class="headerlink" title="配置nginx访问"></a>配置nginx访问</h3><hr><pre><code>vim /etc/fdfs/mod_fastdfs.conf#需要修改的内容如下tracker_server=192.168.52.1:22122  #tracker服务器IP和端口url_have_group_name=truestore_path0=/home/dfs#配置nginx.configvim /usr/local/nginx/conf/nginx.conf#添加如下配置server {    listen       8888;    ## 该端口为storage.conf中的http.server_port相同    server_name  localhost;    location ~/group[0-9]/ {        ngx_fastdfs_module;    }    error_page   500 502 503 504  /50x.html;    location = /50x.html {    root   html;    }}#测试下载，用外部浏览器访问刚才已传过的nginx安装包,引用返回的IDhttp://192.168.52.1:8888/group1/M00/00/00/wKgAQ1pysxmAaqhAAA76tz-dVgg.tar.gz#弹出下载单机部署全部跑通</code></pre><h2 id="分布式部署"><a href="#分布式部署" class="headerlink" title="分布式部署"></a>分布式部署</h2><hr><h3 id="tracker配置-1"><a href="#tracker配置-1" class="headerlink" title="tracker配置"></a>tracker配置</h3><hr><pre><code>#服务器ip为 192.168.52.2,192.168.52.3,192.168.52.4#我建议用ftp下载下来这些文件 本地修改vim /etc/fdfs/tracker.conf#需要修改的内容如下port=22122  # tracker服务器端口（默认22122,一般不修改）base_path=/home/dfs  # 存储日志和数据的根目录</code></pre><h3 id="storage配置-1"><a href="#storage配置-1" class="headerlink" title="storage配置"></a>storage配置</h3><hr><pre><code>vim /etc/fdfs/storage.conf#需要修改的内容如下port=23000  # storage服务端口（默认23000,一般不修改）base_path=/home/dfs  # 数据和日志文件存储根目录store_path0=/home/dfs  # 第一个存储目录tracker_server=192.168.52.2:22122  # 服务器1tracker_server=192.168.52.3:22122  # 服务器2tracker_server=192.168.52.4:22122  # 服务器3http.server_port=8888  # http访问文件的端口(默认8888,看情况修改,和nginx中保持一致)</code></pre><h3 id="client测试-1"><a href="#client测试-1" class="headerlink" title="client测试"></a>client测试</h3><hr><pre><code>vim /etc/fdfs/client.conf#需要修改的内容如下base_path=/home/moe/dfstracker_server=192.168.52.2:22122  # 服务器1tracker_server=192.168.52.3:22122  # 服务器2tracker_server=192.168.52.4:22122  # 服务器3#保存后测试,返回ID表示成功 如：group1/M00/00/00/xx.tar.gzfdfs_upload_file /etc/fdfs/client.conf /usr/local/src/nginx-1.15.4.tar.gz</code></pre><h2 id="配置nginx访问-1"><a href="#配置nginx访问-1" class="headerlink" title="配置nginx访问"></a>配置nginx访问</h2><hr><pre><code>vim /etc/fdfs/mod_fastdfs.conf#需要修改的内容如下tracker_server=192.168.52.2:22122  # 服务器1tracker_server=192.168.52.3:22122  # 服务器2tracker_server=192.168.52.4:22122  # 服务器3url_have_group_name=truestore_path0=/home/dfs#配置nginx.configvim /usr/local/nginx/conf/nginx.conf#添加如下配置server {    listen       8888;    ## 该端口为storage.conf中的http.server_port相同    server_name  localhost;    location ~/group[0-9]/ {        ngx_fastdfs_module;    }    error_page   500 502 503 504  /50x.html;    location = /50x.html {    root   html;    }}</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><hr><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><hr><pre><code>#不关闭防火墙的话无法使用systemctl stop firewalld.service #关闭systemctl restart firewalld.service #重启</code></pre><h3 id="tracker"><a href="#tracker" class="headerlink" title="tracker"></a>tracker</h3><hr><pre><code>/etc/init.d/fdfs_trackerd start #启动tracker服务/etc/init.d/fdfs_trackerd restart #重启动tracker服务/etc/init.d/fdfs_trackerd stop #停止tracker服务chkconfig fdfs_trackerd on #自启动tracker服务</code></pre><h3 id="storage"><a href="#storage" class="headerlink" title="storage"></a>storage</h3><hr><pre><code>/etc/init.d/fdfs_storaged start #启动storage服务/etc/init.d/fdfs_storaged restart #重动storage服务/etc/init.d/fdfs_storaged stop #停止动storage服务chkconfig fdfs_storaged on #自启动storage服务</code></pre><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><hr><pre><code>/usr/local/nginx/sbin/nginx #启动nginx/usr/local/nginx/sbin/nginx -s reload #重启nginx/usr/local/nginx/sbin/nginx -s stop #停止nginx</code></pre><h2 id="检测集群"><a href="#检测集群" class="headerlink" title="检测集群"></a>检测集群</h2><hr><pre><code>/usr/bin/fdfs_monitor /etc/fdfs/storage.conf# 会显示会有几台服务器 有3台就会 显示 Storage 1-Storage 3的详细信息</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><hr><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><hr><pre><code>tracker_server #有几台服务器写几个group_name #地址的名称的命名bind_addr #服务器ip绑定store_path_count #store_path(数字)有几个写几个store_path(数字) #设置几个储存地址写几个 从0开始</code></pre><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><hr><pre><code>如果不是root 用户 你必须在除了cd的命令之外 全部加sudo如果不是root 用户 编译和安装分开进行 先编译再安装如果上传成功 但是nginx报错404 先检查mod_fastdfs.conf文件中的store_path0是否一致如果nginx无法访问 先检查防火墙 和 mod_fastdfs.conf文件tracker_server是否一致如果不是在/usr/local/src文件夹下安装 可能会编译出错</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 文件服务器 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合详解</title>
      <link href="/2019/05/03/java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/05/03/java%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这里我们分析Collection和Map<br><a href="https://img-blog.csdn.net/20160124221843905" target="_blank" rel="noopener">大图查看详情</a></p></blockquote><h1 id="javaCollection的分析"><a href="#javaCollection的分析" class="headerlink" title="javaCollection的分析"></a>javaCollection的分析</h1><p>Collection是在java.util里面</p><p><img src="https://s2.ax1x.com/2019/04/02/AywLb6.png" alt="Java队列"></p><blockquote><p>集合里面是一定是存放对象的，不能存放基本数据类型，像是int,也是先转换成Integer然后在放在集合中。</p></blockquote><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><a id="more"></a><ul><li>List是一个接口，而下面有ArrayList和LinkList两个实现类，关于Array和Linkd的区别，详见数据结构。</li><li>List是有顺序的！</li><li>Vector(同步) 非常类似ArrayList，但是Vector是同步的 </li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>Set也是一个接口，下面有HashSet和TreeSet两个实现类</li><li>HashSet: HashSet类按照哈希算法来存取集合中的对象，存取速度比较快。 里面的对象可能会被打乱，但是效率更高。</li><li>TreeSet: TreeSet类实现了SortedSet接口，能够对集合中的对象进行排序。 保证对象的有序性</li><li>Set里面没有重复数据  这样可以去重<br>| 重要方法    | 作用                                                         |<br>| ———– | ———————————————————— |<br>| iterator( ) | 主要用于递归集合，返回一个Iterator()对象，利用Iterator()去接收 |<blockquote><p>《后期添加》注意：这个Iterator是Collection下面的 。</p></blockquote></li></ul><h2 id="Deque-amp-amp-Queue"><a href="#Deque-amp-amp-Queue" class="headerlink" title="Deque &amp;&amp; Queue"></a>Deque &amp;&amp; Queue</h2><ul><li>其实Deque是Queue的一个接口，是父子关系</li><li><p>注意他的子接口Deque下面有两个实现类ArrayDeque…</p><p>  <img src="https://s2.ax1x.com/2019/04/28/EQg5N9.png" alt></p></li></ul><ul><li><p>Queue是一个普通队列，详情见数据结构</p></li><li><p>Deque是Queue的子接口，他是一个双端队列，可以支持FIFO(First Input First Output)和LIFO原则。</p></li></ul><h3 id="队列基础"><a href="#队列基础" class="headerlink" title="队列基础"></a>队列基础</h3><ul><li>BlockingQueue阻塞队列:当添加队列的时候，可以去设置等待时间。即当队列满的时候，可以等待，超过等待时间返回false。取队列的时候也可以等待。</li><li>ConcurrentLinkedQueue非阻塞队列，添加和取队列的时候不去等待。</li><li>队列原则</li><li><ul><li>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。从某种程度上来说这种队列也体现了一种公平性。</li></ul></li><li><ul><li>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件。　　<blockquote><p>Tips: 非阻塞队列比阻塞队列效率要好，但是确实不安全的</p></blockquote></li></ul></li></ul><hr><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue()"></a>ConcurrentLinkedQueue<e>()</e></h4><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">offer</td><td style="text-align:left">将Object添加到队列的尾部</td></tr><tr><td style="text-align:left">poll</td><td style="text-align:left">从队列头取Object并且将其在队列中删除</td></tr><tr><td style="text-align:left">peek</td><td style="text-align:left">从队列头取Object并且不将其在队列中删除</td></tr></tbody></table><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="BlockingQueue-Size"><a href="#BlockingQueue-Size" class="headerlink" title="BlockingQueue(Size)"></a>BlockingQueue<e>(Size)</e></h4><p><img src="https://s2.ax1x.com/2019/04/08/A4Oysx.png" alt="常用队列"></p><ul><li><p>ArrayBlockingQueue 数组型队列，必须要指定size</p></li><li><p>linkedBlockingQueue  链表型无界队列，可以指定size</p></li></ul><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">offer()</td><td style="text-align:left">将Object添加到队列的尾部&lt;非阻塞式&gt;</td></tr><tr><td style="text-align:left">offer(Object,time,timeUtil)</td><td style="text-align:left">将Object添加到队列的尾部&lt;阻塞式&gt;,设定队满的时候等待时间</td></tr><tr><td style="text-align:left">poll</td><td style="text-align:left">从队列头取Object并且将其在队列中删除&lt;非阻塞式&gt;</td></tr><tr><td style="text-align:left">poll(Object,time,timeUtil)</td><td style="text-align:left">队列头取Object并且将其在队列中删除&lt;阻塞式&gt;,设定队空的时候等待时间</td></tr><tr><td style="text-align:left">peek</td><td style="text-align:left">从队列头取Object并且不将其在队列中删除</td></tr></tbody></table><blockquote><p>这里要注意： add()方法和offer方法的区别，add方法在队列满的情况下会抛出一个异常。而offer并不会。|</p></blockquote><h1 id="Map分析"><a href="#Map分析" class="headerlink" title="Map分析"></a>Map分析</h1>]]></content>
      
      
      <categories>
          
          <category> javaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> javase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7安装redis</title>
      <link href="/2019/04/30/Centos7%E5%AE%89%E8%A3%85redis/"/>
      <url>/2019/04/30/Centos7%E5%AE%89%E8%A3%85redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos7安装redis"><a href="#Centos7安装redis" class="headerlink" title="Centos7安装redis"></a>Centos7安装redis</h1><p>我的安装包版本是redis5.6</p><a id="more"></a><h2 id="准备安装"><a href="#准备安装" class="headerlink" title="准备安装"></a>准备安装</h2><hr><p>安装redis需要gcc环境</p><pre><code>yum install gcc</code></pre><p>准备redis5.6的tar包，我这里离线下载的</p><pre><code># 这里我解压到了桌面 /root/桌面tar -zxvf redis...   #解压</code></pre><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><hr><pre><code>make MALLOC=libcmake install  # 这里会将启动程序安装到 /usr/local/bin下面cd /usr/local/bin./redis-server #测试运行</code></pre><p>如果出现下面的图片则证明启动成功。<img src="https://s2.ax1x.com/2019/04/30/E8A5h6.png" alt></p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><hr><p>在/path/下 我这里则是/root/桌面/redis5.6/redis.conf修改下面的变量</p><pre><code>vi redis.conf#下面是修改项daemonize yesrequirepass 123  #这个是密码 可以自定义#注释下列选项 这样就可以远程连接bind 127.0.0.1</code></pre><p>移动redis.conf到/usr/local/bin下</p><pre><code>cp redis.conf /usr/local/bin</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code>cd /usr/local/bin./redis-server redis.conf &amp;</code></pre><p>利用本地电脑的redis可视化工具测试连接</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql优化初探</title>
      <link href="/2019/04/29/mysql%E4%BC%98%E5%8C%96%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/04/29/mysql%E4%BC%98%E5%8C%96%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL优化初探"><a href="#MySQL优化初探" class="headerlink" title="MySQL优化初探"></a>MySQL优化初探</h1><p>这里用的是Mysql5.6.34win64版本</p><h2 id="设计数据库"><a href="#设计数据库" class="headerlink" title="设计数据库"></a>设计数据库</h2><p>3F范式</p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>垂直分割</p><p>水平分割取模算法</p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><a id="more"></a><hr><p>下面是我的配置文件</p><pre><code class="properties"># For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html# *** DO NOT EDIT THIS FILE. It&#39;s a template which will be copied to the# *** default location during install, and will be replaced if you# *** upgrade to a newer version of MySQL.[mysqld]character_set_server = utf8# Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M# Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_binlog_bin=ON#错误日志#log_error=D:\Program Files\mysql-5.6.34-winx64\data\logs\err.log#全查询日志 #log_output=FILE  #不启用的话慢日志查询会存在数据表中general_log=ongeneral_log_file=query.log#慢查询日志slow_query_log=on   long_query_time=2#时间为2sslow_query_log_file=slowquery.log# These are commonly set, remove the # and set as required. basedir = D:\Program Files\mysql-5.6.34-winx64# 日志存放目录 datadir = D:\Program Files\mysql-5.6.34-winx64\data port = 3306# server_id = .....#二进制日志配置，第二、三行配置最后一个binlog-bin和binlog是不加后缀的文件名，不加后缀的话有妙用server_id=1#log_bin=D:\Program Files\mysql-5.6.34-winx64\data\bin_log\binlog-bin#log_bin_index=D:\Program Files\mysql-5.6.34-winx64\data\bin_log\binlog# Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2M sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES </code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote><p>当数据有重复的时候，如何降低幂等</p><p>唯一索引</p></blockquote><h2 id="定位慢查询"><a href="#定位慢查询" class="headerlink" title="定位慢查询"></a>定位慢查询</h2><p>日志配置在上面，将慢查询时间设置好(默认是10秒)，重启mysql服务，之后如果超过设定时间，就会记录在log日志中。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java设计模式初探</title>
      <link href="/2019/04/24/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/04/24/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java设计模式初探"><a href="#java设计模式初探" class="headerlink" title="java设计模式初探"></a>java设计模式初探</h1><hr><h2 id="java反射机制"><a href="#java反射机制" class="headerlink" title="java反射机制"></a>java反射机制</h2><blockquote><p>我们平常都是通过new一个类来实例化一个对象，但是我们同时可以通过反射机制来构建，并且动态获取类里面的信息 比如说构造函数，方法和属性。</p></blockquote><p>常用的代码像是这个：</p><a id="more"></a><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>Class&lt;?&gt; Class.forName(“全类名”)</td><td>加载该类对象，并且通过这个方法可以获得类的信息</td></tr><tr><td>xxx.newInstance()</td><td>实例化一个对象，这个我一般和上面的代码一起用来实例化对象</td></tr><tr><td>Class.forName(“xx”).getDeclaredxxx</td><td>获得该类的信息</td></tr></tbody></table><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li>单利模式的共同点就是将构造函数私有化。</li></ul><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><pre><code class="java">public class UserEntity {    private String username;    private static final  UserEntity user = new UserEntity();    static {        System.out.println(&quot;静态代码块&quot;);    }    private UserEntity() {        System.out.println(&quot;默认构造函数&quot;);    }    {        System.out.println(&quot;非静态代码块&quot;);    }    public static UserEntity getInstance(){        return user;    }    public void setUsername(String username){        this.username = username;    }    public String getUsername(){        return username;    }}</code></pre><ul><li>通过对该类进行java反射可以知道，static代码块在Class.forName装载的时候开始执行，而实例化的时候非静态代码块和构造函数开始执行</li></ul><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul><li>实体类在需要的时候才创建。</li></ul><pre><code class="java">public class UserEntity {    private String username;    private static UserEntity user;    static {        System.out.println(&quot;静态代码块&quot;);    }    private UserEntity() {        System.out.println(&quot;默认构造函数&quot;);    }    {        System.out.println(&quot;非静态代码块&quot;);    }    /*这里加锁保证线程安全*/    public synchronized static UserEntity getInstance(){        if(user == null){            user = new UserEntity();        }        return user;    }    public void setUsername(String username){        this.username = username;    }    public String getUsername(){        return username;    }}</code></pre><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre><code class="java">public class UserEntity2 {    private UserEntity2() {    }    public static class SingleInstance{        private static final UserEntity2 user = new UserEntity2();    }    public static UserEntity2 getInstance(){       return SingleInstance.user;    }}</code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code class="java">//使用枚举实现单例模式 优点:实现简单、枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞 缺点没有延迟加载public class User {    public static User getInstance() {        return SingletonDemo04.INSTANCE.getInstance();    }    private static enum SingletonDemo04 {        INSTANCE;        // 枚举元素为单例        private User user;        private SingletonDemo04() {            System.out.println(&quot;SingletonDemo04&quot;);            user = new User();        }        public User getInstance() {            return user;        }    }    public static void main(String[] args) {        User u1 = User.getInstance();        User u2 = User.getInstance();        System.out.println(u1 == u2);    }}</code></pre><h3 id="双重检验锁"><a href="#双重检验锁" class="headerlink" title="双重检验锁"></a>双重检验锁</h3><p>可以看作是对懒汉式的一个改版 </p><pre><code class="java">public class SingletonDemo04 {    private SingletonDemo04 singletonDemo04;    private SingletonDemo04() {    }    public SingletonDemo04 getInstance() {        if (singletonDemo04 == null) {            synchronized (this) {                if (singletonDemo04 == null) {                    singletonDemo04 = new SingletonDemo04();                }            }        }        return singletonDemo04;    }}</code></pre><h3 id="单例模式的选择"><a href="#单例模式的选择" class="headerlink" title="单例模式的选择"></a>单例模式的选择</h3><p>如果不需要延迟加载单例，可以使用<strong>枚举</strong>或者<strong>饿汉式</strong>，相对来说枚举性好于饿汉式。</p><p>如果需要延迟加载，可以使用静态内部类或者懒汉式，相对来说静态内部类好于懒韩式。</p><p>最好使用饿汉式  </p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul><li>工厂模式将实例化的工作从客户手里夺了回来，Spring的依赖反转也是这个道理</li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul><li>简单工厂一般代码不会更改，拓展性差</li></ul><p><img src="https://s2.ax1x.com/2019/04/28/EQ4BAU.png" alt></p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><ul><li>工厂方法一般是如果产品非常多的情况下，派生出不同的工厂去实例化不同的产品。</li></ul><p><img src="https://s2.ax1x.com/2019/04/28/EQoDN8.png" alt></p><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><blockquote><p>这里分清楚产品族和产品树的关联</p></blockquote><p>在下面的图中，两个产品有关联的实体形成了产品族，一个工厂只生产一个产品族。</p><p>产品树可以理解为由一个接口派生出来的类。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQo4EV.png" alt></p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><ul><li>这个方法是平时用的蛮多的一个</li><li>其实模板方法就是将子类都利用的方法在父类中写好。</li></ul><p><img src="https://s2.ax1x.com/2019/04/28/EQTdxJ.png" alt></p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><ul><li>Builder 可以根据客户提交的参数自定义产品的零件来产生不同的产品，这也是建造者模式和工厂模式的一个很大的区别。</li></ul><p><img src="https://s2.ax1x.com/2019/04/28/EQ7JOA.png" alt></p><h3 id="建造者的应用场景"><a href="#建造者的应用场景" class="headerlink" title="建造者的应用场景"></a>建造者的应用场景</h3><ul><li>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。</li><li>JAVA 中的 StringBuilder。 </li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>通过代理控制对象的访问,可以详细访问某个对象的方法，在这个方法调用处理，或调用后处理。SpringAOP就是代理模式</p><p><img src="https://s2.ax1x.com/2019/04/28/EQ7DSg.png" alt></p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理一般都是将代码写死了，在项目中用的也很少，理解即可。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQ7fYT.png" alt></p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p>静态代理有很大的缺陷，就是如果像让很多类都就行切面，不可能都去写进Proxy里面，这样动态代理就可以解决这个问题。</p></blockquote><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><pre><code class="java">// 每次生成动态代理类对象时,实现了InvocationHandler接口的调用处理器对象 public class InvocationHandlerImpl implements InvocationHandler {    private Object target;// 这其实业务实现类对象，用来调用具体的业务方法    // 通过构造函数传入目标对象    public InvocationHandlerImpl(Object target) {        this.target = target;    }    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        Object result = null;        System.out.println(&quot;调用开始处理&quot;);        result = method.invoke(target, args);        System.out.println(&quot;调用结束处理&quot;);        return result;    }    public static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException,            IllegalAccessException, IllegalArgumentException, InvocationTargetException {        // 被代理对象        IUserDao userDao = new UserDao();        InvocationHandlerImpl invocationHandlerImpl = new InvocationHandlerImpl(userDao);        ClassLoader loader = userDao.getClass().getClassLoader();        Class&lt;?&gt;[] interfaces = userDao.getClass().getInterfaces();        // 主要装载器、一组接口及调用处理动态代理实例        IUserDao newProxyInstance = (IUserDao) Proxy.newProxyInstance(loader, interfaces, invocationHandlerImpl);        newProxyInstance.save();    }}</code></pre><h4 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h4><p>需要asm-all和cglib的jar包</p><pre><code class="java">public class CglibProxy implements MethodInterceptor {    private Object targetObject;    // 这里的目标类型为Object，则可以接受任意一种参数作为被代理类，实现了动态代理    public Object getInstance(Object target) {        // 设置需要创建子类的类        this.targetObject = target;        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(target.getClass());        enhancer.setCallback(this);        return enhancer.create();    }    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {        System.out.println(&quot;开启事物&quot;);        Object result = proxy.invoke(targetObject, args);        System.out.println(&quot;关闭事物&quot;);        // 返回代理对象        return result;    }    public static void main(String[] args) {        CglibProxy cglibProxy = new CglibProxy();        UserDao userDao = (UserDao) cglibProxy.getInstance(new UserDao());        userDao.save();    }}</code></pre><h2 id="门面-外观-模式"><a href="#门面-外观-模式" class="headerlink" title="门面(外观)模式"></a>门面(外观)模式</h2><p>外观模式，其实就是将后面很复杂的方法封装成一个类里面，让客户直接调用封装类里面的方法即可。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQblKH.png" alt></p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQqPFP.jpg" alt></p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>现实开发中如果我们由一个根据不同情况创建不同实体的情况下，无论是用if-else或者是swith实现，代码是不符合开闭原则的，也就是他的拓展性并不高。</p><p>那么，策略模式，解决了这个问题。其实，他的代码是比之前多了不少，但是这样也同时隐藏后台的核心代码，只将Strategy接口交给了用户，保证了一定的安全性。</p><p><img src="https://s2.ax1x.com/2019/04/28/EQqb0s.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java锁的深入理解</title>
      <link href="/2019/04/21/java%E9%94%81%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
      <url>/2019/04/21/java%E9%94%81%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="java锁的深入理解"><a href="#java锁的深入理解" class="headerlink" title="java锁的深入理解"></a>java锁的深入理解</h1><hr><h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>这个锁相当于一个递归锁，如果上层代码已经获得到了锁的所有权，那么他的子代码也直接拥有所有权，重入锁的常见有</p><p>Lock锁(轻量级锁)和synchronize(重量级锁)</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>相比<a href="http://ifeve.com/locks/" target="_blank" rel="noopener">Java中的锁(Locks in Java)</a>里Lock实现，读写锁更复杂一些。假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁。在没有写操作的时候<strong>，两个线程同时读一个资源没有任何问题，所以应该允许多个线程能在同时读取共享资源。但是如果有一个线程想去写这些共享资源，就不应该再有其它线程对该资源进行读或写</strong>（译者注：也就是说：读-读能共存，读-写不能共存，写-写不能共存）。这就需要一个读/写锁来解决这个问题。Java5在java.util.concurrent包中已经包含了读写锁。尽管如此，我们还是应该了解其实现背后的原理。</p><p>这里用一段实例来解释读写锁</p><pre><code class="java">package com.lock;import java.util.HashMap;import java.util.Map;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.concurrent.locks.ReentrantReadWriteLock;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019-2019/4/21-20:46 * Description: :/TODO_ */public class TestMain {    public static void main(String args[]){        new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i &lt; 10; i++) {                    Cache.put(i + &quot;&quot;, i + &quot;&quot;);                }            }        }).start();        new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i &lt; 10; i++) {                    Cache.get(i + &quot;&quot;);                }            }        }).start();    }}class Cache {    static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();    static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();    static Lock r = rwl.readLock();    static Lock w = rwl.writeLock();    // 获取一个key对应的value    public static final Object get(String key) {        r.lock();        try {            System.out.println(&quot;正在做读的操作,key:&quot; + key + &quot; 开始&quot;);            Thread.sleep(100);            Object object = map.get(key);            System.out.println(&quot;正在做读的操作,key:&quot; + key + &quot; 结束&quot;);            System.out.println();            return object;        } catch (InterruptedException e) {        } finally {            r.unlock();        }        return key;    }    // 设置key对应的value，并返回旧有的value    public static final Object put(String key, Object value) {        w.lock();        try {            System.out.println(&quot;正在做写的操作,key:&quot; + key + &quot;,value:&quot; + value + &quot;开始.&quot;);            Thread.sleep(100);            Object object = map.put(key, value);            System.out.println(&quot;正在做写的操作,key:&quot; + key + &quot;,value:&quot; + value + &quot;结束.&quot;);            System.out.println();            return object;        } catch (InterruptedException e) {        } finally {            w.unlock();        }        return value;    }    // 清空所有的内容    public static final void clear() {        w.lock();        try {            map.clear();        } finally {            w.unlock();        }    }}</code></pre><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>这里只是一个描述，乐观锁和CAS无锁机制，他的性能比悲观锁高，因为他并没有利用锁，更不会有死锁问题。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起。可以依靠数据库实现，如行锁、读锁和写锁等，都是在操作之前加锁，在Java中，synchronized的思想也是悲观锁。</p><h2 id="CAS锁"><a href="#CAS锁" class="headerlink" title="CAS锁"></a>CAS锁</h2><p>（1）与锁相比，使用比较交换compare and Swap（下文简称CAS）会使程序看起来更加复杂一些。但由于其非阻塞性，它对死锁问题天生免疫，并且，线程间的相互影响也远远比基于锁的方式要小。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，它要比基于锁的方式拥有更优越的性能。 </p><p>（2）无锁的好处：</p><p>第一，在高并发的情况下，它比有锁的程序拥有更好的性能；</p><p>第二，它天生就是死锁免疫的。</p><p>就凭借这两个优势，就值得我们冒险尝试使用无锁的并发。</p><p>（3）CAS算法的过程是这样：它包含三个参数CAS(V,E,N): V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。</p><p>（4）CAS操作是抱着乐观的态度进行的，它总是认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p><p>（5）简单地说，CAS需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的。如果变量不是你想象的那样，那说明它已经被别人修改过了。你就重新读取，再次尝试修改就好了。</p><p>（6）在硬件层面，大部分的现代处理器都已经支持原子化的CAS指令。在JDK 5.0以后，虚拟机便可以使用这个指令来实现并发操作和并发数据结构，并且，这种操作在虚拟机中可以说是无处不在。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写Future和Callable</title>
      <link href="/2019/04/21/%E6%89%8B%E5%86%99Future%E5%92%8CCallable/"/>
      <url>/2019/04/21/%E6%89%8B%E5%86%99Future%E5%92%8CCallable/</url>
      
        <content type="html"><![CDATA[<h1 id="java-Future和Callable模式"><a href="#java-Future和Callable模式" class="headerlink" title="java Future和Callable模式"></a>java Future和Callable模式</h1><hr><ul><li>我们之前使用的多线程需要在run方法中执行多线程代码，但是run方法有一个致命缺点，就是他的返回值是空。但是，如果我们像要我们如何知道子线程执行完毕呢？没有返回值告诉我们，所以我们需要上面的两种模式。<a id="more"></a><h2 id="Callable模式"><a href="#Callable模式" class="headerlink" title="Callable模式"></a>Callable模式</h2></li></ul><hr><p>其实，Callable就相当于一个有返回值的线程，而Future是一个可以接收Callable的返回值。</p><p>Callable的源代码如下：</p><pre><code class="java">@FunctionalInterfacepublic interface Callable&lt;V&gt; {    /**     * Computes a result, or throws an exception if unable to do so.     *     * @return computed result     * @throws Exception if unable to compute a result     */    V call() throws Exception;}</code></pre><p>他和Runable接口源代码是很相似的。他和Runable的唯一的不同是返回值V是泛型,而Runable是void.</p><p><strong><em>Future常用方法</em></strong></p><p><strong>V get()</strong> <strong>：</strong>获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。</p><p><strong>V get(Long timeout , TimeUnit unit)</strong> ：获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。</p><p><strong>boolean isDone()</strong> <strong>：</strong>如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。</p><p><strong>boolean isCanceller()</strong> <strong>：</strong>如果任务完成前被取消，则返回true。</p><p><strong>boolean cancel(boolean mayInterruptRunning)</strong> <strong>：</strong>如果任务还没开始，执行cancel(…)方法将返回false；如果任务已经启动，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回true；当任务已经启动，执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回false；当任务已经完成，执行cancel(…)方法将返回false。mayInterruptRunning参数表示是否中断执行中的线程。</p><p>通过方法分析我们也知道实际上Future提供了3种功能：（1）能够中断执行中的任务（2）判断任务是否执行完成（3）获取任务执行完成后额结果。</p><hr><p>实例:</p><pre><code class="java">public class TestMain {    public static void main(String[] args) throws InterruptedException, ExecutionException {        ExecutorService executor = Executors.newCachedThreadPool();        Future&lt;Integer&gt; future = executor.submit(new AddNumberTask());        System.out.println(Thread.currentThread().getName() + &quot;线程执行其他任务&quot;);        Integer integer = future.get();        System.out.println(integer);        // 关闭线程池        if (executor != null)            executor.shutdown();    }}class AddNumberTask implements Callable&lt;Integer&gt; {    public AddNumberTask() {    }    @Override    public Integer call() throws Exception {        System.out.println(&quot;####AddNumberTask###call()&quot;);        Thread.sleep(5000);        return 5000;    }}</code></pre><p>Future的好处就是先传给你一个结果,然后等资源全部解析完成之后,再传给你值,相当于ajax的异步.</p><p><img src="https://s2.ax1x.com/2019/04/21/EF0tSO.png" alt></p><h2 id="手写Callable"><a href="#手写Callable" class="headerlink" title="手写Callable"></a>手写Callable</h2><hr><p>仔细一想，这相当于生产者消费者模型。可以用wait和notify来解决。</p><p>核心代码：</p><pre><code class="java">package com.Future;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019-2019/4/21-13:00 * Description: :/TODO_ */public class FutureCore {    //请求参数    private String arg;    //标识变量    private volatile  boolean FLAG = false;    //返回结果    private String result;    public FutureCore(String arg) {        this.arg = arg;    }    //这里可能会有阻塞，模拟下载    public synchronized void setRequest(){        if(FLAG){            return;        }        System.out.println(&quot;接收网络参数&quot; + arg+&quot;;数据请求中...&quot;);        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }        this.result = &quot;结果&quot;;        FLAG = true;        notify();    }    //返回结果    public synchronized String getResult(){        while (!FLAG){            try {                wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }        return result;    }}</code></pre><p>这里是封装future的类</p><pre><code class="java">package com.Future;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019-2019/4/21-13:05 * Description: :/TODO_ */public class FutureUtil {    public static FutureCore submit(String arg){        FutureCore futureCore = new FutureCore(arg);        //子线程开始下载资源        new Thread(new Runnable() {            @Override            public void run() {                futureCore.setRequest();            }        }).start();        //直接返回结果        return futureCore;    }}</code></pre><p>测试主函数如下:</p><pre><code class="java">package com.Future;/** * Created with IntelliJ IDEA. * User: WHOAMI * Time: 2019-2019/4/21-13:09 * Description: :/TODO_ */public class ThreadTest {    public static void main(String args[]){        System.out.println(&quot;开始future&quot;);        FutureCore core = FutureUtil.submit(&quot;测试&quot;);        System.out.println(&quot;主线程继续执行&quot;);        System.out.println(core.getResult());    }}</code></pre><p>结果如下：</p><p><img src="https://s2.ax1x.com/2019/04/21/EF0fmj.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssm+rabbitmq 分布式实例</title>
      <link href="/2019/04/15/ssm-rabbitmq-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/04/15/ssm-rabbitmq-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="在分布式架构下利用rabbitmq完成消息队列"><a href="#在分布式架构下利用rabbitmq完成消息队列" class="headerlink" title="在分布式架构下利用rabbitmq完成消息队列"></a>在分布式架构下利用rabbitmq完成消息队列</h1><hr><h2 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h2><hr><blockquote><p>我们利用rabbit:admin直接代码绑定交换机和队列,这里是开发常用的方法<br>最后我们会利用web端界面实现消息的分发实例</p></blockquote><a id="more"></a><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><hr><h4 id="配置文件详解-1"><a href="#配置文件详解-1" class="headerlink" title="配置文件详解"></a>配置文件详解</h4><hr><ul><li><p>下面是rabbitmq的基础设置</p><pre><code class="xml">&lt;!-- 定义连接工厂 --&gt;&lt;rabbit:connection-factory id=&quot;connectionFactory&quot;                             username=&quot;${mq.username}&quot; password=&quot;${mq.password}&quot; host=&quot;${mq.host}&quot; port=&quot;${mq.port}&quot;                             virtual-host=&quot;${mq.vh}&quot; /&gt;  &lt;!-- 定义rabbit template 用于数据的接收和发送 --&gt;  &lt;rabbit:template id=&quot;amqpTemplate&quot; connection-factory=&quot;connectionFactory&quot;                   exchange=&quot;solrExChange&quot;&gt;&lt;/rabbit:template&gt;</code></pre></li><li><p>定义队列</p></li></ul><pre><code class="xml"> &lt;!--定义queue  说明：durable:是否持久化 exclusive: 仅创建者可以使用的私有队列，断开后自动删除 auto_delete: 当所有消费客户端连接断开后，是否自动删除队列--&gt;    &lt;rabbit:queue name=&quot;chase1&quot; durable=&quot;true&quot; auto-delete=&quot;false&quot; exclusive=&quot;false&quot; /&gt;</code></pre><ul><li>定义交换机，这里我们定义topic模式,这里我们绑定队列</li></ul><pre><code class="xml"> &lt;!--topic 模式：发送端不是按固定的routing key发送消息，而是按字符串“匹配”发送，接收端同样如此。 --&gt;&lt;!--durable : 是否持久化 auto-delete：是否自动删除  --&gt;    &lt;rabbit:topic-exchange name=&quot;solrExChange&quot;                           durable=&quot;true&quot; auto-delete=&quot;false&quot;&gt;         &lt;rabbit:bindings&gt;             &lt;!-- 这个pattern是topic特有的通配符模式 --&gt;            &lt;rabbit:binding queue=&quot;chase1&quot; pattern=&quot;item.#&quot;&gt;&lt;/rabbit:binding&gt;        &lt;/rabbit:bindings&gt;    &lt;/rabbit:topic-exchange&gt;</code></pre><ul><li>利用代码同步队列和交换机</li></ul><pre><code class="xml">&lt;!-- 通过指定下面的admin信息，当前productor中的exchange和queue会在rabbitmq服务器上自动生成 --&gt;    &lt;rabbit:admin id=&quot;amqpAdmin&quot; connection-factory=&quot;connectionFactory&quot; /&gt;</code></pre><blockquote><p>注意: 如果这里不写rabbit:admin,也就是说我们利用rabbitmq的web界面手动绑定的话,我们并不需要在交换机上绑定队列和定义队列</p></blockquote><ul><li><p>完成的配置文件</p><ul><li>applicationContext-rabbit.xml</li></ul></li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    http://www.springframework.org/schema/rabbit    http://www.springframework.org/schema/rabbit/spring-rabbit-1.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 引入外部数据库的配置文件，location位置填写的是相对位置 --&gt;    &lt;context:property-placeholder location=&quot;classpath:properties/rabbit.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt;    &lt;rabbit:connection-factory id=&quot;connectionFactory&quot;    username=&quot;${mq.username}&quot; password=&quot;${mq.password}&quot; host=&quot;${mq.host}&quot; port=&quot;${mq.port}&quot;    virtual-host=&quot;${mq.vh}&quot; /&gt;    &lt;!-- 定义rabbit template 用于数据的接收和发送 --&gt;    &lt;rabbit:template id=&quot;amqpTemplate&quot; connection-factory=&quot;connectionFactory&quot;    exchange=&quot;solrExChange&quot;&gt;&lt;/rabbit:template&gt;    &lt;!--定义queue  说明：durable:是否持久化 exclusive: 仅创建者可以使用的私有队列，断开后自动删除 auto_delete: 当所有消费客户端连接断开后，是否自动删除队列--&gt;    &lt;rabbit:queue name=&quot;chase1&quot; durable=&quot;true&quot; auto-delete=&quot;false&quot; exclusive=&quot;false&quot; /&gt;    &lt;!--topic 模式：发送端不是按固定的routing key发送消息，而是按字符串“匹配”发送，接收端同样如此。 --&gt;    &lt;rabbit:topic-exchange name=&quot;solrExChange&quot;    durable=&quot;false&quot; auto-delete=&quot;false&quot;&gt;        &lt;rabbit:bindings&gt;            &lt;rabbit:binding queue=&quot;chase1&quot; pattern=&quot;item.#&quot;&gt;&lt;/rabbit:binding&gt;        &lt;/rabbit:bindings&gt;    &lt;/rabbit:topic-exchange&gt;    &lt;!-- 通过指定下面的admin信息，当前productor中的exchange和queue会在rabbitmq服务器上自动生成 --&gt;    &lt;rabbit:admin id=&quot;amqpAdmin&quot; connection-factory=&quot;connectionFactory&quot; /&gt;&lt;/beans&gt;</code></pre><h4 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h4><hr><pre><code class="java">package com.rabbit.producer.service;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import javax.annotation.Resources;/** * Created with IntelliJ IDEA. * User: WHOAMI * Date: 2019/4/15 * Time: 8:46 * Description: :/TODO_ */@Servicepublic class RabbitService  {    //注入模板    @Autowired    private AmqpTemplate amqpTemplate;    public void SendTest(){        System.out.println(&quot;开始发送消息&quot;);        //这里是代码核心处       amqpTemplate.convertAndSend(&quot;item.message&quot;,&quot;发送消息&quot;);    }}</code></pre><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><hr><h4 id="配置文件详解-2"><a href="#配置文件详解-2" class="headerlink" title="配置文件详解"></a>配置文件详解</h4><hr><ul><li><p>下面是rabbitmq的基础设置</p><pre><code class="xml">&lt;!-- 定义连接工厂 --&gt;&lt;rabbit:connection-factory id=&quot;connectionFactory&quot;                             username=&quot;${mq.username}&quot; password=&quot;${mq.password}&quot; host=&quot;${mq.host}&quot; port=&quot;${mq.port}&quot;                             virtual-host=&quot;${mq.vh}&quot; /&gt;  &lt;!-- 定义rabbit template 用于数据的接收和发送 --&gt;  &lt;rabbit:template id=&quot;amqpTemplate&quot; connection-factory=&quot;connectionFactory&quot;                   exchange=&quot;solrExChange&quot;&gt;&lt;/rabbit:template&gt;</code></pre></li><li><p>定义队列</p></li></ul><pre><code class="xml"> &lt;!--定义queue  说明：durable:是否持久化 exclusive: 仅创建者可以使用的私有队列，断开后自动删除 auto_delete: 当所有消费客户端连接断开后，是否自动删除队列--&gt;    &lt;rabbit:queue name=&quot;chase1&quot; durable=&quot;true&quot; auto-delete=&quot;false&quot; exclusive=&quot;false&quot; /&gt;</code></pre><ul><li>利用代码同步队列和交换机</li></ul><pre><code class="xml">&lt;!-- 通过指定下面的admin信息，当前productor中的exchange和queue会在rabbitmq服务器上自动生成 --&gt;    &lt;rabbit:admin id=&quot;amqpAdmin&quot; connection-factory=&quot;connectionFactory&quot; /&gt;</code></pre><ul><li><p>定义消费者</p><pre><code class="xml">&lt;!-- 消息接收者 具体到特定类 --&gt;  &lt;bean id=&quot;Consumer&quot; class=&quot;com.rabbit.consumer.utils.Consumer&quot;&gt;&lt;/bean&gt;</code></pre></li><li><p>定义监听器</p></li></ul><pre><code class="xml">&lt;!-- queue litener 观察 监听模式 当有消息到达时会通知监听在对应的队列上的监听对象    acknowledeg = &quot;manual&quot;，意为表示该消费者的ack方式为手动 默认为auto--&gt;    &lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot; acknowledeg = &quot;manual&quot;&gt;        &lt;rabbit:listener  queues=&quot;chase1&quot;  ref=&quot;Consumer&quot;/&gt;    &lt;/rabbit:listener-container&gt;</code></pre><ul><li>完成配置文件</li></ul><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    http://www.springframework.org/schema/rabbit    http://www.springframework.org/schema/rabbit/spring-rabbit-1.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 引入外部数据库的配置文件，location位置填写的是相对位置 --&gt;    &lt;context:property-placeholder location=&quot;classpath:properties/rabbit.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt;    &lt;rabbit:connection-factory id=&quot;connectionFactory&quot;    username=&quot;${mq.username}&quot; password=&quot;${mq.password}&quot; host=&quot;${mq.host}&quot; port=&quot;${mq.port}&quot;    virtual-host=&quot;${mq.vh}&quot; /&gt;    &lt;!--定义queue  说明：durable:是否持久化 exclusive: 仅创建者可以使用的私有队列，断开后自动删除 auto_delete: 当所有消费客户端连接断开后，是否自动删除队列--&gt;    &lt;rabbit:queue name=&quot;chase1&quot; durable=&quot;true&quot; auto-delete=&quot;false&quot; exclusive=&quot;false&quot; /&gt;    &lt;!-- 消息接收者 --&gt;    &lt;bean id=&quot;Consumer&quot; class=&quot;com.rabbit.consumer.utils.Consumer&quot;&gt;&lt;/bean&gt;    &lt;!-- queue litener 观察 监听模式 当有消息到达时会通知监听在对应的队列上的监听对象    acknowledeg = &quot;manual&quot;，意为表示该消费者的ack方式为手动--&gt;    &lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;manual&quot;&gt;        &lt;rabbit:listener  queues=&quot;chase1&quot;  ref=&quot;Consumer&quot;/&gt;    &lt;/rabbit:listener-container&gt;    &lt;!-- 通过指定下面的admin信息，当前productor中的exchange和queue会在rabbitmq服务器上自动生成 --&gt;    &lt;rabbit:admin connection-factory=&quot;connectionFactory&quot; /&gt;&lt;/beans&gt;</code></pre><h4 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h4><hr><p>我们要定义消费者，那么我们需要实现ChannelAwareMessageListener 和 MessageListener接口</p><ul><li>两个接口源码如下</li></ul><pre><code class="java">public interface MessageListener {    void onMessage(Message message);}public interface ChannelAwareMessageListener {    void onMessage(Message message, Channel channel) throws Exception;}</code></pre><blockquote><p>个人说明： 这两个接口的区别就是 Channel 会手动进行ack</p></blockquote><pre><code class="java">package com.rabbit.consumer.utils;import com.rabbitmq.client.Channel;import org.springframework.amqp.core.Message;import org.springframework.amqp.rabbit.core.ChannelAwareMessageListener;import org.springframework.stereotype.Component;/** * Created with IntelliJ IDEA. * User: WHOAMI * Date: 2019/4/15 * Time: 9:01 * Description: :/TODO_ */@Componentpublic class Consumer implements ChannelAwareMessageListener {    @Override    public void onMessage(Message message, Channel channel) throws Exception {        String msg = new String(message.getBody(),&quot;utf-8&quot;);        //消息的标识，false只确认当前一个消息收到，true确认所有consumer获得的消息        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);        //ack返回false，并重新回到队列，api里面解释得很清楚//        channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);        //true拒绝消息 false确认接受到消息        //channel.basicReject(message.getMessageProperties().getDeliveryTag(), false);        System.out.println(&quot;消费者消费掉了消息:&quot; + msg);    }}</code></pre><h2 id="错误笔记"><a href="#错误笔记" class="headerlink" title="错误笔记"></a>错误笔记</h2><hr><p>注意 ，如果web端里面有配置文件里面声明的交换机或者队列，如果配置文件里面 declare或者auto-delete不相同的时候会爆出500的错误！并且不会绑定数据！</p><p><img src="https://s2.ax1x.com/2019/04/15/Ajj3Mq.png" alt></p><p><img src="https://s2.ax1x.com/2019/04/15/Ajj0zR.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> j2EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssm </tag>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>freemaker传输数据问题</title>
      <link href="/2019/04/13/freemaker%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/13/freemaker%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="FreeMaker传输数据问题"><a href="#FreeMaker传输数据问题" class="headerlink" title="FreeMaker传输数据问题"></a>FreeMaker传输数据问题</h1><hr><ul><li>正常输出方程式 ${XXX}</li><li>如果页面需要字符串，那么我们需要 在变量两边加引号 ‘${XXX}’</li><li>如果传输的是数字，在超出100的时候，会自行加逗号，例如1,400,解决办法： ${XXX?c}</li></ul><a id="more"></a><ul><li><p>如果你的字段是null的话，freemaker直接引用是会报错的<br><img src="https://s2.ax1x.com/2019/04/13/AL5JCF.png" alt></p><p>这样需要你在可能出现错误的字段上加一个判断他是否为空，$(XXX!”啊，这是null”)</p></li></ul><ul><li>其实在判断字符串的时候 例如 &lt;#if sex= “男”&gt; 和 &lt;#if sex== “男”&gt; 是一样的</li></ul>]]></content>
      
      
      <categories>
          
          <category> ssm错误笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误笔记 </tag>
            
            <tag> ssm </tag>
            
            <tag> freemaker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装solr服务</title>
      <link href="/2019/04/12/centos7%E5%AE%89%E8%A3%85solr%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/04/12/centos7%E5%AE%89%E8%A3%85solr%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="centos7-下安装solr服务"><a href="#centos7-下安装solr服务" class="headerlink" title="centos7 下安装solr服务"></a>centos7 下安装solr服务</h1><h2 id="1-安装java环境"><a href="#1-安装java环境" class="headerlink" title="1. 安装java环境"></a>1. 安装java环境</h2><hr><ul><li><p>将jdk扔到linux下，解压</p></li><li><p>修改环境变量</p></li></ul><pre><code># 打开配置文件vim /etc/profile # 在文件末尾添加JAVA_HOME=/usr/local/java/jdk1.8.0_201CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jarPATH=$PATH:$JAVA_HOME/binexport JAVA_HOME CLASSPATH PATH#保存并关闭source /etc/profile</code></pre><h2 id="2-安装solr"><a href="#2-安装solr" class="headerlink" title="2. 安装solr"></a>2. 安装solr</h2><hr><ol><li><p>下载solr安装包 [官方网址]:(<a href="http://www.apache.org/dyn/closer.lua/lucene/solr/8.0.0" target="_blank" rel="noopener">http://www.apache.org/dyn/closer.lua/lucene/solr/8.0.0</a>)</p></li><li><p>扔到linux下，解压</p><a id="more"></a></li><li>cd到目录下\bin</li></ol><pre><code> ./solr start -force #默认启动8983端口</code></pre><blockquote><p>注意 ，这里我并没有修改文件限制，linux会限制传输文件大小<br><img src="https://s2.ax1x.com/2019/04/12/AbujvF.png" alt></p><ol start="4"><li>关闭防火墙<pre><code>systemctl stop firewalld</code></pre></li></ol></blockquote><ol start="5"><li>打开游览器，访问 192.168.xx.xx.8983</li></ol><h2 id="3-solr功能介绍"><a href="#3-solr功能介绍" class="headerlink" title="3.solr功能介绍"></a>3.solr功能介绍</h2><hr><p><img src="https://s2.ax1x.com/2019/04/12/AbajBt.png" alt></p><p><img src="https://s2.ax1x.com/2019/04/12/Abdp4S.png" alt></p><h2 id="4-配置solr"><a href="#4-配置solr" class="headerlink" title="4. 配置solr"></a>4. 配置solr</h2><hr><h3 id="配置core环境"><a href="#配置core环境" class="headerlink" title="配置core环境"></a>配置core环境</h3><hr><ul><li><p>打开solr-admin</p></li><li><p>按照下图操作<br><img src="https://s2.ax1x.com/2019/04/12/AbKrxU.png" alt></p></li><li><p>之后会提示错误，因为找不到config和schema文件</p></li><li>打开linux，在%安装目录%/server/configsets/_default/下的conf文件copy到 %安装目录%/server/%core名称%/ 下</li><li>重新创建core</li><li>看到自己的core文件夹下面出现这几个文件，证明安装成功<br><img src="https://s2.ax1x.com/2019/04/12/AbMCLQ.png" alt></li></ul><h3 id="配置中文分词器"><a href="#配置中文分词器" class="headerlink" title="配置中文分词器"></a>配置中文分词器</h3><hr><blockquote><p>其实solr8.0已经自带了中文分词器<br><img src="https://s2.ax1x.com/2019/04/12/AbMuyF.png" alt></p></blockquote><ul><li><p>但是为了业务要求，我们使用IK分词器</p><p>ik可以去maven仓库去下载</p><p><img src="https://s2.ax1x.com/2019/04/12/AbtyfH.png" alt></p></li><li><p>将三个jar包放到%solr安装包%/server/solr-webapp/webapp/WEB-INF/lib/下</p></li><li><p>将剩余的三个文件放到%solr安装包%/server/solr-webapp/webapp/WEB-INF/classes/下[如果没有，自己新建]</p></li><li><p>配置ik 打开%自己CORE%/conf/managed-schema.xml文件</p></li></ul><pre><code>    &lt;!-- ik分词器 --&gt;        &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;        &lt;!-- 索引分词器 --&gt;        &lt;analyzer type=&quot;index&quot; isMaxWordLength=&quot;false&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;        &lt;!-- 查询分词器 --&gt;        &lt;analyzer type=&quot;query&quot; isMaxWordLength=&quot;true&quot; class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt;        &lt;/fieldType&gt;</code></pre><ul><li>重启 ./solr restart -force</li></ul><h3 id="配置业务域FileType"><a href="#配置业务域FileType" class="headerlink" title="配置业务域FileType"></a>配置业务域FileType</h3><hr><p>打开%自己CORE%/conf/managed-schema.xml文件</p><pre><code>&lt;field name=&quot;item_title&quot; type=&quot;text_en&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_sell_point&quot; type=&quot;text_en&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_price&quot;  type=&quot;plong&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;&lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_category_name&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;&lt;field name=&quot;item_desc&quot; type=&quot;text_en&quot; indexed=&quot;true&quot; stored=&quot;false&quot; /&gt;&lt;field name=&quot;item_keywords&quot; type=&quot;text_en&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;&lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt;&lt;copyField source=&quot;item_sell_point&quot; dest=&quot;item_keywords&quot;/&gt;</code></pre><p>重启 ./solr restart -forces</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> java </tag>
            
            <tag> 搜索服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java自定义线程池</title>
      <link href="/2019/04/08/java%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/04/08/java%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="java线程池"><a href="#java线程池" class="headerlink" title="java线程池"></a>java线程池</h1><h2 id="java初始定义线程"><a href="#java初始定义线程" class="headerlink" title="java初始定义线程"></a>java初始定义线程</h2><p><img src="https://s2.ax1x.com/2019/04/08/A4XAkF.png" alt></p><h2 id="java线程池源码分析"><a href="#java线程池源码分析" class="headerlink" title="java线程池源码分析"></a>java线程池源码分析</h2><p><img src="https://s2.ax1x.com/2019/04/08/A5iM28.png" alt></p><pre><code class="java">/**     * Creates a new {@code ThreadPoolExecutor} with the given initial     * parameters and default rejected execution handler.     *     * @param corePoolSize the number of threads to keep in the pool, even     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set     * @param maximumPoolSize the maximum number of threads to allow in the     *        pool     * @param keepAliveTime when the number of threads is greater than     *        the core, this is the maximum time that excess idle threads     *        will wait for new tasks before terminating.     * @param unit the time unit for the {@code keepAliveTime} argument     * @param workQueue the queue to use for holding tasks before they are     *        executed.  This queue will hold only the {@code Runnable}     *        tasks submitted by the {@code execute} method.     * @param threadFactory the factory to use when the executor     *        creates a new thread     * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;     *         {@code corePoolSize &lt; 0}&lt;br&gt;     *         {@code keepAliveTime &lt; 0}&lt;br&gt;     *         {@code maximumPoolSize &lt;= 0}&lt;br&gt;     *         {@code maximumPoolSize &lt; corePoolSize}     * @throws NullPointerException if {@code workQueue}     *         or {@code threadFactory} is null     */    public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory) {        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,             threadFactory, defaultHandler);    }</code></pre><ol><li>corePoolSize 表示常驻核心线程数。如果等于0，则任务执行完成后，没有任何请求进入时销毁线程池的线程；如果大于0，即使本地任务执行完毕，核心线程也不会被销毁。这个值的设置非常关键，设置过大会浪费资源，设置的过小会导致线程频繁地创建或销毁。再考虑到keepAliveTime和allowCoreThreadTimeOut超时参数的影响，所以没有任务需要执行的时候，线程池的大小不一定是corePoolSize。</li><li>maximumPoolSize 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize；当阻塞队列是无界队列, 则maximumPoolSize则不起作用, 因为无法提交至核心线程池的线程会一直持续地放入workQueue.</li></ol><h2 id="合理配置线程数"><a href="#合理配置线程数" class="headerlink" title="合理配置线程数"></a>合理配置线程数</h2><hr><h3 id="分析需求"><a href="#分析需求" class="headerlink" title="分析需求"></a>分析需求</h3><p>根据需求的不同，可以将技术分成IO密集和CPU密集两种类型。</p><p>IO密集：</p><p>线程中存在大量的阻塞，例如，请求，数据库连接，。。。线程会有大量的等待，这样会有等待时间，那么这个线程就是IO密集型，一般这种类型，配置核心线程数的规则是 core = 2*CPU内核</p><p>CPU密集：</p><p>线程中代码非常多，而且计算的内容非常多，阻塞少，这个就是CPU密集，配置规则是：core = CPU内核。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7安装rabbitMQ</title>
      <link href="/2019/04/07/centos7%E5%AE%89%E8%A3%85rabbitMQ/"/>
      <url>/2019/04/07/centos7%E5%AE%89%E8%A3%85rabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="centos安装RabbitMQ并配置环境"><a href="#centos安装RabbitMQ并配置环境" class="headerlink" title="centos安装RabbitMQ并配置环境"></a>centos安装RabbitMQ并配置环境</h1><p>之前我在网上搜罗了很多教程，但是大多都很繁琐，要么就是版本太老。</p><p>这里我提供了一个非常简单的方法</p><a id="more"></a><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><hr><p>打开[官网地址]: (<a href="https://www.rabbitmq.com/releases/" target="_blank" rel="noopener">https://www.rabbitmq.com/releases/</a>)  </p><p>如下图：</p><p><img src="https://s2.ax1x.com/2019/04/14/AOb5kR.png" alt></p><ul><li>这里我们需要erlang和rabbitmq-server<ul><li>打开对应网址下载最新的rpm安装包</li></ul></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr><blockquote><p>将安装包利用xftp传输到linux，注意不要直接拖拽，安装包容易出问题。</p></blockquote><ul><li>在断网的时候安装erlang，因为我的centos7 的yum源会自动安装低版本的erlang。</li></ul><pre><code>yum install xxx  #安装软件yum list installed #查看利用yum安装的所有软件yum remove xxx #卸载软件rpm -ql [rabbitmq-server] #查看软件安装在那里</code></pre><ul><li>在联机的情况下安装rabbitmq，因为他需要安装socat依赖。</li></ul><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><hr><p>由于我这里是用来做javaweb的消息中间件，所以我需要他可以http访问，所以需要添加插件</p><pre><code>  rabbitmq-plugins enable rabbitmq_management</code></pre><p>启动rabbitmq程序</p><pre><code>rabbitmq-server start</code></pre><p>其他命令</p><pre><code>rabbitmq-server restart #重启rabbitmqctl stop   #停止rabbitmqctl status  #状态</code></pre><blockquote><p>这里插播一条linux命令</p><pre><code>ps -ef|grep xxx  #查询所有xxx的进程kill -9 xxx #杀死进程端口号为xxx的进程</code></pre></blockquote><ul><li>注意！默认guest guest账户已经不能允许在远程登陆，所以我们需要创建账号</li></ul><h2 id="配置rabbitmq"><a href="#配置rabbitmq" class="headerlink" title="配置rabbitmq"></a>配置rabbitmq</h2><hr><p>下面我们创建账号，注意 这时候rabbitmq必须是启动状态</p><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><hr><pre><code>rabbitmqctl add_user root 111111 #创建账号rabbitmqctl set_user_tags root administrator #设置root为管理员rabbitmqctl list_users #查询所有用户</code></pre><h3 id="ui模式"><a href="#ui模式" class="headerlink" title="ui模式"></a>ui模式</h3><hr><p><img src="https://s2.ax1x.com/2019/04/07/Afjlg1.png" alt="操作"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7下设置静态ip</title>
      <link href="/2019/04/03/centos7%E4%B8%8B%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81ip/"/>
      <url>/2019/04/03/centos7%E4%B8%8B%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81ip/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux设置固定IP-并不能上网"><a href="#Linux设置固定IP-并不能上网" class="headerlink" title="Linux设置固定IP[并不能上网]"></a>Linux设置固定IP[并不能上网]</h1><blockquote><p>一般我们想要拿本地的linux当做服务器用来测试，但是我们的ip设置规则时DHCP,即自动分配ip原则，所以为了方便，这里记录了如何固定ip的方法</p></blockquote><p>我们要设置ip，要知道VM的网络适配器有三种原则</p><ul><li>桥接模式</li><li>主机模式</li><li>NAT模式</li></ul><p>我们的真实主机有两块对应的网卡</p><ul><li>VMnet0</li><li>VMnet8<a id="more"></a></li></ul><p>由于我们这里只固定ip，所以别的我们现在先不了解。</p><hr><h2 id="首先设置网关，打开VM的虚拟网络适配器"><a href="#首先设置网关，打开VM的虚拟网络适配器" class="headerlink" title="首先设置网关，打开VM的虚拟网络适配器"></a>首先设置网关，打开VM的虚拟网络适配器</h2><hr><p><img src="https://s2.ax1x.com/2019/04/03/Ag94FH.png" alt="网络适配器"></p><p>修改我们的子网ip和子网掩码，注意！上面的框只有里面的3你可以自行修改！</p><h2 id="修改主机的VM网卡-VMnet8"><a href="#修改主机的VM网卡-VMnet8" class="headerlink" title="修改主机的VM网卡 VMnet8"></a>修改主机的VM网卡 VMnet8</h2><hr><p><img src="https://s2.ax1x.com/2019/04/03/Ag9pqO.png" alt></p><h2 id="按照下图操作"><a href="#按照下图操作" class="headerlink" title="按照下图操作"></a>按照下图操作</h2><hr><p><img src="https://s2.ax1x.com/2019/04/03/Ag9bOf.png" alt="操作"></p><p>其中也是建议只有3更改</p><hr><h2 id="注意linux选择NAT链接后，开始修改IP！"><a href="#注意linux选择NAT链接后，开始修改IP！" class="headerlink" title="注意linux选择NAT链接后，开始修改IP！"></a>注意linux选择NAT链接后，开始修改IP！</h2><hr><pre><code>ip addr#记住画圈的这个文件名，之后会用到</code></pre><p><img src="https://s2.ax1x.com/2019/04/03/AgClnK.png" alt></p><h2 id="打开下面的文件"><a href="#打开下面的文件" class="headerlink" title="打开下面的文件"></a>打开下面的文件</h2><hr><pre><code> cd /etc/sysconfig/network-scripts</code></pre><p><img src="https://s2.ax1x.com/2019/04/03/AgPGrV.png" alt></p><pre><code>vim ifcfg-ens33# 修改下面的两处为#BOOTPROTO=static#ONBOOT=yes#并在下面添加网址等信息IPADDR=192.168.3.135#静态IPGATEWAY=192.168.3.2 #默认网关NETMASK=255.255.255.0 #子网掩码</code></pre><p><img src="https://s2.ax1x.com/2019/04/03/AgPTqf.png" alt></p><h2 id="重启网络服务"><a href="#重启网络服务" class="headerlink" title="重启网络服务"></a>重启网络服务</h2><hr><pre><code>service network restart</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal原理分析</title>
      <link href="/2019/04/02/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2019/04/02/ThreadLocal%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal原理分析"><a href="#ThreadLocal原理分析" class="headerlink" title="ThreadLocal原理分析"></a>ThreadLocal原理分析</h1><p>需求：如果我们引入一个全局变量，但是他的值在每个线程需要互相不影响。</p><blockquote><p>解决办法1:可以根据线程的次数new 几次实体类 ，然后分别装进每个线程中，但是如果线程数量很大并且不确定，这个方法不符合实际。</p></blockquote><blockquote><p>解决办法2：将实体类的变量设置为ThreadLocal类型</p></blockquote><a id="more"></a><h2 id="ThreadLocal案例引入"><a href="#ThreadLocal案例引入" class="headerlink" title="ThreadLocal案例引入"></a>ThreadLocal案例引入</h2><pre><code class="java">package com.Thread.Test;class Local{//一定要初始化变量的值    ThreadLocal&lt;Integer&gt; count = new ThreadLocal&lt;Integer&gt;(){        @Override        protected Integer initialValue() {            return 0;        }    };    public void set(){        this.count.set(this.count.get()+1);    }    public Integer get(){        return count.get();    }}class ThreadTest implements Runnable{    Local local;    public ThreadTest(Local local) {        this.local = local;    }    @Override    public void run() {        for (int i=0;i&lt;3;i++){            local.set();            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+local.get());        }    }}public class Main {    public static void main(String[] args) throws InterruptedException {        Local local = new Local();        Thread thread1 = new Thread(new ThreadTest(local));        Thread thread2 = new Thread(new ThreadTest(local));        Thread thread3 = new Thread(new ThreadTest(local));        thread1.start();        thread2.start();        thread3.start();    }}</code></pre><h2 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h2><ul><li>将变量设置成一个Map类型，存的时候，将线程的名字和操作一起存入Map进去，取出来的时候，根据自己的线程名字来取</li></ul><p>set方法源码：</p><pre><code class="java">  public void set(T value) {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);    }</code></pre><p>get方法源码：</p><pre><code class="java">  public T get() {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null) {            ThreadLocalMap.Entry e = map.getEntry(this);            if (e != null) {                @SuppressWarnings(&quot;unchecked&quot;)                T result = (T)e.value;                return result;            }        }        return setInitialValue();    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程通信</title>
      <link href="/2019/03/31/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/03/31/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="java-生产者与消费者的模型分析"><a href="#java-生产者与消费者的模型分析" class="headerlink" title="java 生产者与消费者的模型分析"></a>java 生产者与消费者的模型分析</h1><ul><li>技术需求： 当生产者更新一条数据后，会立即通知消费者。</li><li>原理分析图</li><li><img src="https://s2.ax1x.com/2019/03/31/Ar7fN4.png" alt="原理图"></li></ul><a id="more"></a><ul><li>这种需求可以看成一种消息队列<br>我们可以利用多线程来开启两个队列，一个是生产者，另一个是消费者。</li></ul><h2 id="利用synchronized-对象锁来实现线程原子性。"><a href="#利用synchronized-对象锁来实现线程原子性。" class="headerlink" title="利用synchronized 对象锁来实现线程原子性。"></a>利用synchronized 对象锁来实现线程原子性。</h2><pre><code class="java">package com.Thread.Test;//消息模型class Msg{    public String data1;    public String data2;}//生产者线程class Producer extends Thread{    private Msg msg;    private int count = 0;    public Producer(Msg msg) {        this.msg = msg;    }    @Override    public void run() {        while (true){            synchronized (msg){                if(count == 0){                    msg.data1 = &quot;消息1&quot;;                    msg.data2 = &quot;状态1&quot;;                }else{                    msg.data1 = &quot;消息2&quot;;                    msg.data2 = &quot;状态2&quot;;                }                count = (count +1)%2;            }        }    }}//消费者线程class Consumer extends Thread{    private Msg msg;    public Consumer(Msg msg) {        this.msg = msg;    }    @Override    public void run() {        while (true){            synchronized (msg){                System.out.println(&quot;data1:&quot;+msg.data1+&quot;;data2:&quot;+msg.data2);            }        }    }}public class Main {    public static void main(String[] args) throws InterruptedException {        Msg msg = new Msg();        Producer producer = new Producer(msg);        Consumer consumer = new Consumer(msg);        producer.start();        Thread.sleep(300);        consumer.start();    }}</code></pre><p>这里有两个关键点</p><ul><li><strong>为什么要使用对象锁？</strong></li><li>因为如果不利用对象锁的话，这两个线程是不安全的，因为JMM的原因使得线程不可见。</li><li>并且对象锁一定是一致的，不然数据不会同步。</li><li><strong>这个解决方案是否可行？</strong></li><li>并不可以，因为两个线程存在抢占资源锁的情况，所以有可能生产者更新几次资源，但是消费者只显示一次，或者消费者重复显示几次的情况，并不符合我们的预期。</li><li>基于以上两点，我们采用线程通信技术。</li></ul><h2 id="多线程通信常用函数"><a href="#多线程通信常用函数" class="headerlink" title="多线程通信常用函数"></a>多线程通信常用函数</h2><ol><li>wait()函数<br> 该函数基于Object对象，他的作用是，暂时休眠该线程，并且<strong>释放锁资源</strong></li><li>notify()函数<br> 他的作用是唤醒线程池其他线程</li><li>interrupt()函数<br> 将当前正在等待的线程【可以是wait的线程】，直接抛出异常，用来停止线程。<blockquote><p>这两个函数通常都是配套使用，并且一定用在synchronized锁对象的情况下</p></blockquote></li></ol><hr><p>利用上面两个函数进行线程通信</p><pre><code class="java">package com.Thread.Test;//消息模型class Msg{    public String data1;    public String data2;    //假定flag= false 的时候 生产者激活，反之消费者激活    public boolean flag = false;}//生产者线程class Producer extends Thread{    private Msg msg;    private int count = 0;    public Producer(Msg msg) {        this.msg = msg;    }    @Override    public void run() {        while (true){            synchronized (msg){//                此时生产者线程应该休眠                if(msg.flag){                    try {                        Thread.sleep(1000);                        msg.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                if(count == 0){                    msg.data1 = &quot;消息1&quot;;                    msg.data2 = &quot;状态1&quot;;                }else{                    msg.data1 = &quot;消息2&quot;;                    msg.data2 = &quot;状态2&quot;;                }                count = (count +1)%2;                msg.flag = true;                //通知其他线程                msg.notify();            }        }    }}class Consumer extends Thread{    private Msg msg;    public Consumer(Msg msg) {        this.msg = msg;    }    @Override    public void run() {        while (true){            synchronized (msg){                if(!msg.flag){                    try {                        Thread.sleep(1000);                        msg.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                System.out.println(&quot;data1:&quot;+msg.data1+&quot;;data2:&quot;+msg.data2);                msg.flag = false;                msg.notify();            }        }    }}public class Main {    public static void main(String[] args) throws InterruptedException {        Msg msg = new Msg();        Producer producer = new Producer(msg);        Consumer consumer = new Consumer(msg);        producer.start();        consumer.start();    }}</code></pre><h2 id="利用Lock锁实现通信"><a href="#利用Lock锁实现通信" class="headerlink" title="利用Lock锁实现通信"></a>利用Lock锁实现通信</h2><p>Lock锁与synchronized的不同之处在于，wait和notify函数对于lock是没有用的</p><p>不多说，上代码</p><pre><code class="java">package com.Thread.Test;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;//消息模型class Msg2{    public String data1;    public String data2;    //假定flag= false 的时候 生产者激活，反之消费者激活    public boolean flag = false;    public Lock lock = new ReentrantLock();}//生产者线程class Producer2 extends Thread {    private Msg2 msg;    private int count = 0;    private Condition condition;    public Producer2(Msg2 msg, Condition condition) {        this.msg = msg;        this.condition = condition;    }    @Override    public void run() {        while (true) {            try {                msg.lock.lock();//                此时生产者线程应该休眠                if (msg.flag) {                    try {                        Thread.sleep(1000);                        condition.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                if (count == 0) {                    msg.data1 = &quot;消息1&quot;;                    msg.data2 = &quot;状态1&quot;;                } else {                    msg.data1 = &quot;消息2&quot;;                    msg.data2 = &quot;状态2&quot;;                }                count = (count + 1) % 2;                msg.flag = true;                //通知其他线程                condition.signal();            } catch (Exception e) {                e.printStackTrace();            } finally {                msg.lock.unlock();            }        }    }}class Consumer2 extends Thread{    private Msg2 msg;    private Condition condition;    public Consumer2(Msg2 msg, Condition condition) {        this.msg = msg;        this.condition = condition;    }    @Override    public void run() {        while (true){                try {                    msg.lock.lock();                    if(!msg.flag){                        try {                            Thread.sleep(1000);                            condition.await();                        } catch (InterruptedException e) {                            e.printStackTrace();                        }                    }                    System.out.println(&quot;data1:&quot;+msg.data1+&quot;;data2:&quot;+msg.data2);                    msg.flag = false;                    condition.signal();                }catch (Exception e) {                    e.printStackTrace();                }finally {                    msg.lock.unlock();                }            }        }}public class LockTest {    public static void main(String[] args) throws InterruptedException {        Msg2 msg = new Msg2();        //利用Condition来限定通信        Condition newCondition = msg.lock.newCondition();        Producer2 producer = new Producer2(msg,newCondition);        Consumer2 consumer = new Consumer2(msg,newCondition);        producer.start();        consumer.start();    }}</code></pre><h2 id="如何优雅的停止线程（补充）"><a href="#如何优雅的停止线程（补充）" class="headerlink" title="如何优雅的停止线程（补充）"></a>如何优雅的停止线程（补充）</h2><p>首先，放弃Thread.stop()函数<br>要知道，一些线程都是一些while循环的，即可能是while(true)格式的，这样停止他可以用这样的思路：<br>设置一个boolean的flag，当flag = true的时候正常运行，flag = false的时候停止线程。</p><blockquote><p>这时应该考虑线程可见问题。需要将flag修改为 voliate格式。</p></blockquote><p>但是，如果当前的线程是synchronized锁，并且在wait状态下，flag修改对本线程没有什么影响。因为现在线程已经休眠了。<br>那么可以利用interrupt函数让他抛出异常，然后在catch的代码块上面将flag修改。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssm利用ajax上传图片和参数</title>
      <link href="/2019/03/31/ssm%E5%88%A9%E7%94%A8ajax%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%92%8C%E5%8F%82%E6%95%B0/"/>
      <url>/2019/03/31/ssm%E5%88%A9%E7%94%A8ajax%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%92%8C%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Ajax选择性上传图片"><a href="#Ajax选择性上传图片" class="headerlink" title="Ajax选择性上传图片"></a>Ajax选择性上传图片</h1><ul><li>技术选型:</li><li>bootstrap-fileinput 渲染上传框</li><li>FormData 用于传递参数</li><li>bootstrap 前端渲染</li></ul><a id="more"></a><hr><h2 id="技术需求"><a href="#技术需求" class="headerlink" title="技术需求"></a>技术需求</h2><blockquote><p>用于后台CMS更新商品的时候，需要上传图片和参数。但是为了节省流量，这里的图片是选择性上传，也就是说，后台分辨不出来，你到底有没有上传图片。</p><ul><li>功能截图：<br><img src="https://s2.ax1x.com/2019/03/31/Arcftf.png" alt="前端功能截图"></li></ul></blockquote><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="前端代码部分"><a href="#前端代码部分" class="headerlink" title="前端代码部分"></a>前端代码部分</h3><pre><code class="html">&lt;%--编辑的模态框--%&gt;&lt;div class=&quot;modal fade&quot; id=&quot;editContent&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot;&gt;    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;        &lt;div class=&quot;modal-content&quot;&gt;            &lt;div class=&quot;modal-header text-center&quot;&gt;                &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;                &lt;h4 class=&quot;modal-title&quot;&gt;商品信息修改&lt;/h4&gt;            &lt;/div&gt;            &lt;div class=&quot;modal-body&quot;&gt;                &lt;form class=&quot;form-horizontal&quot; id=&quot;editContentForm&quot;&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;编号&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;id&quot;  id=&quot;contentId_update&quot; disabled=&quot;disabled&quot;/&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;内容标题&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;title&quot; class=&quot;form-control&quot; id=&quot;contentTitle_update&quot;&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;子标题&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;subTitle&quot; class=&quot;form-control&quot; id=&quot;contentSubTitle_update&quot;&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;标题描述&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;titleDesc&quot; class=&quot;form-control&quot; id=&quot;contentTitleDesc_update&quot;&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;链接&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;url&quot; class=&quot;form-control&quot; id=&quot;contentUrl_update&quot;&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group hidden&quot; &gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;所属分类&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;categoryId&quot; class=&quot;form-control&quot; id=&quot;contentCategoryId_update&quot; disabled=&quot;disabled&quot;&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;图片&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;file&quot; name=&quot;picFile&quot; id=&quot;contentPic_update&quot; /&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;图片2&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;file&quot; name=&quot;pic2File&quot; id=&quot;contentPic2_update&quot;/&gt;                        &lt;/div&gt;                        &lt;/div&gt;                    &lt;div class=&quot;form-group&quot;&gt;                        &lt;label class=&quot;col-sm-2 control-label&quot;&gt;内容&lt;/label&gt;                        &lt;div class=&quot;col-sm-10&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;content&quot; class=&quot;form-control&quot; id=&quot;contentContent_update&quot;&gt;                        &lt;/div&gt;                    &lt;/div&gt;                &lt;/form&gt;            &lt;/div&gt;            &lt;div class=&quot;modal-footer&quot;&gt;                &lt;div class=&quot;col-sm-12&quot;&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-default col-sm-5&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt;                    &lt;button type=&quot;button&quot; class=&quot;btn btn-primary pull-right col-sm-5&quot; onclick= &quot;emp_update_btn()&quot;&gt;更新&lt;/button&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;//ajax异步上传function emp_update_btn () {        //没有检验数据是否正确 请注意        var formdata = new FormData($(&quot;#editContentForm&quot;)[0]);        formdata.append(&quot;id&quot;,$(&quot;#contentId_update&quot;).val());        $.ajax({          url:&#39;${pageContext.request.contextPath}/content/updateContent.do&#39;,            type:&#39;post&#39;,            dataType:&#39;json&#39;,            contentType: false,            processData: false,            data:formdata,            success:function (result) {                if(result.result === &quot;success&quot;){                    swal(&quot;成功&quot;,&quot;成功更新数据！&quot;,&quot;success&quot;);                    listAll();                    $(&quot;#editContent&quot;).modal(&quot;hide&quot;);                }            }        });&lt;/script&gt;</code></pre><ul><li>需要注意的是 这里和通常的ajax不一样,他传输的不是一般的JSON对象,而是FormData对象,他的写法也和平常的写法不一样</li><li><img src="https://s2.ax1x.com/2019/03/31/Arge3D.png" alt="ajax注意点"></li><li>关于那个图片到底有没有上传的功能,前端不需要考虑</li></ul><hr><h3 id="后台代码部分"><a href="#后台代码部分" class="headerlink" title="后台代码部分"></a>后台代码部分</h3><pre><code class="java">    @Value(&quot;${FILE_URL}&quot;)    private  String FILE_URL;    /**     * function:更新商品     * @param tbContent     * @param pic     * @param pic2     * @return     */    @RequestMapping(value = &quot;/updateContent.do&quot;)    @ResponseBody    public Map&lt;String,String&gt; updateContent(TbContent tbContent, @RequestParam(value = &quot;picFile&quot;,required = false)MultipartFile pic, @RequestParam(value = &quot;pic2File&quot;,required = false)MultipartFile pic2) throws IOException {        HashMap&lt;String,String&gt; map = new HashMap&lt;&gt;();        System.out.println(pic + &quot;:&quot;+FILE_URL);        String picFileID = new String();        String pic2FileID =new String();        if(!pic.isEmpty()){             picFileID = FastDFSClient.uploadFile(pic.getInputStream(),pic.getOriginalFilename());            if(picFileID == null){                map.put(&quot;result&quot;,&quot;failed&quot;);                return map;            }            tbContent.setPic(FILE_URL+picFileID);            System.out.println(tbContent.getPic());        }        if(!pic2.isEmpty()){            pic2FileID = FastDFSClient.uploadFile(pic2.getInputStream(),pic2.getOriginalFilename());            if(pic2FileID == null){                map.put(&quot;result&quot;,&quot;failed&quot;);                return map;            }            tbContent.setPic2(pic2FileID);        }        try {            contentService.updateContent(tbContent);        } catch (IOException e) {            e.printStackTrace();            map.put(&quot;result&quot;,&quot;failed&quot;);            return map;        }        map.put(&quot;result&quot;,&quot;success&quot;);        return map;    }}</code></pre><blockquote><p>之前我用TbContent实体类去接收前端参数的时候，会加上@RequestBody,但是会报出400/415错误，因为FormData的编码并不是application/json;charset = utf-8 ，需要把这个注解删除。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> j2EE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件服务器 </tag>
            
            <tag> 分布式 </tag>
            
            <tag> nginx反向代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内存模型</title>
      <link href="/2019/03/30/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/03/30/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="java内存模型-JMM"><a href="#java内存模型-JMM" class="headerlink" title="java内存模型(JMM)"></a>java内存模型(JMM)</h1><p>+这里来复习一下java多线程的三大特性 ： 原子性，可见性，有序性。</p><ul><li><p><strong>什么是原子性</strong></p></li><li><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>一个很经典的例子就是银行账户转账问题：<br>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。这2个操作必须要具备原子性才能保证不出现一些意外的问题。<br>我们操作数据也是如此，比如i = i+1；其中就包括，读取i的值，计算i，写入i。这行代码在Java中是不具备原子性的，则多线程运行肯定会出问题，所以也需要我们使用同步和lock这些东西来确保这个特性了。<br>原子性其实就是保证数据一致、线程安全一部分，<br><strong>这个也可以理解为数据库的事务</strong></p><a id="more"></a></li><li><p><strong>什么是可见性</strong></p></li><li><p>当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></li><li><p>若两个线程在不同的cpu，那么线程1改变了i的值还没刷新到主存，线程2又使用了i，那么这个i值肯定还是之前的，线程1对变量的修改线程没看到这就是可见性问题。 </p></li><li><p><strong>什么是有序性</strong></p></li><li><p>程序执行的顺序按照代码的先后顺序执行。</p></li><li><p>一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。如下：<br>int a = 10;    //语句1<br>int r = 2;    //语句2<br>a = a + 3;    //语句3<br>r = a*a;     //语句4<br>则因为重排序，他还可能执行顺序为 2-1-3-4，1-3-2-4<br>但绝不可能 2-1-4-3，因为这打破了依赖关系。<br>显然重排序对单线程运行是不会有任何问题，而多线程就不一定了，所以我们在多线程编程时就得考虑这个问题了。</p></li></ul><ul><li>注意不要将JMM和JVM的内存机制混淆在一起。</li></ul><h2 id="java可见性原理分析"><a href="#java可见性原理分析" class="headerlink" title="java可见性原理分析"></a>java可见性原理分析</h2><ul><li>java多线程内存读写机制<ul><li><img src="https://s2.ax1x.com/2019/03/30/ABcR00.png" alt="java多线程内存读写机制"></li></ul></li></ul><blockquote><p>假如线程在同一时刻拿到副本，并且对这个副本就行自增操作，那么返回回来的变量并没有+2，而是+1，这就暴露了线程不同步问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程安全初窥探</title>
      <link href="/2019/03/29/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%9D%E7%AA%A5%E6%8E%A2/"/>
      <url>/2019/03/29/java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%9D%E7%AA%A5%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java线程安全"><a href="#java线程安全" class="headerlink" title="java线程安全"></a>java线程安全</h1><ul><li>知识点： 线程同步 线程并发</li><li>问题描述：在当处理全局变量的时候，当两个或者以上的线程处理同一个<strong> 全局 </strong>变量的时候，可能会出现冲突问题。<a id="more"></a></li></ul><hr><h2 id="java-同步函数"><a href="#java-同步函数" class="headerlink" title="java 同步函数"></a>java 同步函数</h2><p>首先看一下问题场景</p><pre><code class="java">package com.Thread.Test;/** * 抢票问题的一个案例分析 */class ThreadTrain implements Runnable{    private int TrainCount = 100;    @Override    public void run() {            while (TrainCount&gt;0){                try {                    Thread.sleep(50);                } catch (InterruptedException e) {                    e.printStackTrace();                }                sale();            }    }    private void sale(){        System.out.println(Thread.currentThread().getName()+&quot;：正在出售第&quot;+(100-TrainCount+1)+&quot;张票&quot;);        TrainCount--;    }}public class Main {    public static void main(String[] args) {    //开辟两个线程        ThreadTrain threadTrain = new ThreadTrain();        Thread t1 = new Thread(threadTrain, &quot;窗口一&quot;);        Thread t2 = new Thread(threadTrain, &quot;窗口二&quot;);        t1.start();        t2.start();    }}</code></pre><blockquote><p><img src="https://s2.ax1x.com/2019/03/29/A0Gqk6.png" alt="Console ："><br><img src="https://s2.ax1x.com/2019/03/29/A0GHTx.png" alt="Console :"><br>可以看到 上图 会出现两个线程同时贩卖一张票的情况，而且最后会出现贩卖101张票的时候</p></blockquote><ul><li>那么为什么会产生这样的问题呢？<ul><li>原因分析： 是因为两个线程当时同时处于运行状态，那么他们接收的全局变量的value是相等的，那么就会出现贩卖同一张票的情况，这样就会产生线程不安全的情况！</li><li>解决方案分析：就像是购票的原理一样，会对数据库进行锁表，来实现数据同步，java也有锁这种东西</li><li><ul><li>synchronize  —- &gt;自动锁</li></ul></li><li><ul><li>lock  –&gt; jdk1.5 手动锁</li></ul></li></ul></li></ul><h3 id="synchronize-解决代码："><a href="#synchronize-解决代码：" class="headerlink" title="synchronize 解决代码："></a>synchronize 解决代码：</h3><pre><code class="java">package com.Thread.Test;/** * 抢票问题的一个案例分析 */class ThreadTrain implements Runnable{    private int TrainCount = 100;    @Override    public void run() {        while (TrainCount&gt;0){            try {                Thread.sleep(50);            } catch (InterruptedException e) {                e.printStackTrace();            }            sale();        }    }    //synchronized 分成 函数 和标识两个      private synchronized void sale(){ //this锁//        synchronized (this){        //加一个判断 判断最后一张票的两个线程情况        if(TrainCount&gt;0){            System.out.println(Thread.currentThread().getName()+&quot;：正在出售第&quot;+(100-TrainCount+1)+&quot;张票&quot;);            TrainCount--;        }//        }    }}public class Main {    public static void main(String[] args) {        ThreadTrain threadTrain = new ThreadTrain();        Thread t1 = new Thread(threadTrain, &quot;窗口一&quot;);        Thread t2 = new Thread(threadTrain, &quot;窗口二&quot;);        t1.start();        t2.start();    }}</code></pre><blockquote><p>synchronize 方法 比较方便，但是拓展性不高，资源占用大</p></blockquote><h3 id="lock锁的解决办法"><a href="#lock锁的解决办法" class="headerlink" title="lock锁的解决办法"></a>lock锁的解决办法</h3><pre><code class="java">package com.Thread.Test;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class ThreadTrain implements Runnable{    private int TrainCount = 100;    private Lock lock = new ReentrantLock();    @Override    public void run() {        while (TrainCount&gt;0){            try {                Thread.sleep(50);                sale();            } catch (Exception e) {                e.printStackTrace();            }        }    }    //synchronized 分成 函数 和标识两个    private  void sale(){ //this锁        try {            lock.lock();            if(TrainCount&gt;0){                System.out.println(Thread.currentThread().getName()+&quot;：正在出售第&quot;+(100-TrainCount+1)+&quot;张票&quot;);                TrainCount--;            }        }catch (Exception e) {            e.printStackTrace();        }finally {            lock.unlock();        }    }}public class LockTest {    public static void main(String args[]) throws InterruptedException {        ThreadTrain threadTrain = new ThreadTrain();        Thread t1 = new Thread(threadTrain, &quot;窗口一&quot;);        Thread t2 = new Thread(threadTrain, &quot;窗口二&quot;);        t1.start();        Thread.sleep(40);        t2.start();    }}</code></pre><hr><p><img src="https://s2.ax1x.com/2019/03/29/A0RwV0.png" alt="result"></p><ul><li>值得注意的是 如果将函数标识成synchronized锁的话，这个函数只是一个this锁，但是如果使用synchronized函数的话，函数的变量可以定义任何Object类型</li><li>如果是用lock锁的话，如果代码在加锁的过程中，程序崩溃报错，那么这个锁就一直会在锁定状态，所以应该用try catch的时候，在finally加上unlock保证锁的正常运行</li><li>通过锁来实现数据同步，来解决一个像是抢票的并发问题。</li></ul><hr><h2 id="java静态同步函数"><a href="#java静态同步函数" class="headerlink" title="java静态同步函数"></a>java静态同步函数</h2><ul><li>如果将synchroized锁函数名前面加上static 标识限制的时候，那么这个函数不再是一个this锁，而是锁本类的java对象<br>例如<br><code>`</code> java<br>private static synchronized void sale(){ //this锁<br>//        synchronized (this){<pre><code>  //加一个判断 判断最后一张票的两个线程情况  if(TrainCount&gt;0){      System.out.println(Thread.currentThread().getName()+&quot;：正在出售第&quot;+(100-TrainCount+1)+&quot;张票&quot;);      TrainCount--;  }</code></pre></li></ul><p>//        }<br>    }</p><pre><code>是和下面的功能是一样的```java private  void sale(){ //this锁        synchronized (ThreadTrain.class){        //加一个判断 判断最后一张票的两个线程情况        if(TrainCount&gt;0){            System.out.println(Thread.currentThread().getName()+&quot;：正在出售第&quot;+(100-TrainCount+1)+&quot;张票&quot;);            TrainCount--;        }        }    }</code></pre><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><ul><li>千万不要在数据同步的时候在嵌套一个数据锁，这样可能产生一个线程死锁</li><li>具体代码如下<br><code>`</code>java<br>package com.Thread.Test;</li></ul><p>/**</p><ul><li>抢票问题的一个案例分析<br>*/</li></ul><p>class ThreadTrain implements Runnable{</p><pre><code>private int TrainCount = 100;private Object oj = new Object();public boolean flag = true;@Overridepublic void run() {    if(flag){        while (TrainCount&gt;0){            synchronized (oj){                //加一个判断 判断最后一张票的两个线程情况                sale();            }        }    }else{        while(TrainCount&gt;0){            sale();        }    }}private synchronized void sale(){    synchronized (oj){    //加一个判断 判断最后一张票的两个线程情况    if(TrainCount&gt;0){        try {            Thread.sleep(40);        } catch (Exception e) {        }        System.out.println(Thread.currentThread().getName()+&quot;：正在出售第&quot;+(100-TrainCount+1)+&quot;张票&quot;);        TrainCount--;    }    }}</code></pre><p>}</p><p>public class Main {</p><pre><code>public static void main(String[] args) throws InterruptedException {    ThreadTrain threadTrain = new ThreadTrain();    Thread t1 = new Thread(threadTrain, &quot;窗口一&quot;);    Thread t2 = new Thread(threadTrain, &quot;窗口二&quot;);    t1.start();    Thread.sleep(40);    threadTrain.flag = false;    t2.start();}</code></pre><p>}</p><p><code>`</code></p><p><img src="https://s2.ax1x.com/2019/03/30/AB6zyn.png" alt="运行结果"></p><blockquote><p>产生原因： 一个线程已经占用了Object锁之后，打算进入this锁。但是第二个线程从flag = false那里的代码块直接占用this锁，从而第一个线程进不去sale()方法，而第二个方法执行sale()方法需要解开Object锁，导致死锁的产生。<br>这就好比是两个好友分别有对方的密码盒，并且都有自己钥匙，但是都不会把钥匙给对方，从而会产生一个谁也打不就开密码盒的尴尬情况。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> 线程安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java守护线程与非守护线程</title>
      <link href="/2019/03/28/java%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/03/28/java%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="java守护线程与非守护线程窥探"><a href="#java守护线程与非守护线程窥探" class="headerlink" title="java守护线程与非守护线程窥探"></a>java守护线程与非守护线程窥探</h1><hr><h2 id="两个线程的基本概念"><a href="#两个线程的基本概念" class="headerlink" title="两个线程的基本概念"></a>两个线程的基本概念</h2><ul><li>守护线程即在后台为用户提供一些基本保障的线程，例如java中的gc线程[垃圾处理机制],他会自动清理一些没有用处的变量空间，处理空间溢出等问题。守护线程会随着main函数的结束而结束。</li><li>非守护线程，也成为用户线程，他是可以由用户自己定义，不会随着main函数的结束而结束，这个特性和守护线程恰恰相反。</li></ul><a id="more"></a><hr><h2 id="守护线程的机制"><a href="#守护线程的机制" class="headerlink" title="守护线程的机制"></a>守护线程的机制</h2><blockquote><p>举一个实例，当手机游览器正在下载文件的时候，如果你将游览器退出，但是那个文件还在继续下载，那个文件还在继续下载，这个下载文件线程就是守护线程。</p></blockquote><ul><li>值得注意的是，当程序的所有用户线程都结束的时候，并且程序中仅仅剩下了一个守护线程，那么JVM就会退出，因为守护线程已经没有什么可以守护的了。</li><li>但是需要一提的是，java中的main函数属于用户线程，并不属于守护线程!!!!</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程初窥探</title>
      <link href="/2019/03/27/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E7%AA%A5%E6%8E%A2/"/>
      <url>/2019/03/27/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9D%E7%AA%A5%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h1><p>多线程的作用就是提高应用程序的运行效率，提高用户的体验。那么，和多线程相近的进程又是什么意思呢？这两个有什么作用呢？</p><a id="more"></a><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>打开计算机的任务管理器可以看到里面有很多的应用程序正在运行，那么这些程序就是许许多多的进程。</li><li>进程可以看成一个线程的集合【List】,许许多多的线程合成了一个进程，也就是我们的应用程序。<h3 id="计算机如何进行许多应用程序的？"><a href="#计算机如何进行许多应用程序的？" class="headerlink" title="计算机如何进行许多应用程序的？"></a>计算机如何进行许多应用程序的？</h3></li><li>通过CPU对不同的应用程序进行不停的切换，也就是轮询？给用户了一种很多程序同时进行的假象，但是你打开一个程序很长时间不用，突然打开会有一瞬间的卡顿，这样就能看出他其实并不是和你当前的程序有着相同的地位的。</li><li><img src="http://pp1zup2fb.bkt.clouddn.com/java-1.png" alt="多线程实现原理"></li></ul><hr><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li><strong>多线程</strong></li><li>开辟多线程是为了提高应用程序的运行效率。</li><li>开辟多线程之后，代码将不会从上至下进行。</li><li><ul><li><strong>主线程和子线程</strong></li></ul></li><li>子线程一般都是用类自己定义然后开启，他们的行为将受限于主线程。<h3 id="线程的执行方法"><a href="#线程的执行方法" class="headerlink" title="线程的执行方法"></a>线程的执行方法</h3></li><li>继承Thread方法，并且重写Run方法，然后启动start服务</li><li>实现Runable方法，重写Run方法，并且将线程类交给Thread类去构建。然后start服务</li><li>利用匿名类</li><li>[开发中常用]利用线程池开启服务</li></ul><hr><h3 id="多线程的具体实现"><a href="#多线程的具体实现" class="headerlink" title="多线程的具体实现"></a>多线程的具体实现</h3><ol><li>继承Thread</li></ol><pre><code class="java">/** *  * @classDesc: 功能描述:(创建多线程例子-Thread类 重写run方法) * @author: WHOAMI * @version: v1.0 */class CreateThread extends Thread {    // run方法中编写 多线程需要执行的代码    publicvoid run() {        for (inti = 0; i&lt; 10; i++) {            System.out.println(&quot;i:&quot; + i);        }    }}publicclass ThreadDemo {    publicstaticvoid main(String[] args) {        System.out.println(&quot;-----多线程创建开始-----&quot;);        // 1.创建一个线程        CreateThread createThread = new CreateThread();        // 2.开始执行线程 注意 开启线程不是调用run方法，而是start方法        //3. 如果调用run方法，那么这个类就和普通的类没有区别        System.out.println(&quot;-----多线程创建启动-----&quot;);        createThread.start();        System.out.println(&quot;-----多线程创建结束-----&quot;);    }}</code></pre><ol start="2"><li>实现Runable接口</li></ol><pre><code class="java">/** *  * @classDesc: 功能描述:(创建多线程例子-Thread类 重写run方法) * @author: WHOAMI * @version: v1.0 */class CreateRunnable implements Runnable {    @Override    publicvoid run() {        for (inti = 0; i&lt; 10; i++) {            System.out.println(&quot;i:&quot; + i);        }    }}/** *  * @classDesc: 功能描述:(实现Runnable接口,重写run方法) * @author: WHOAMI * @version: v1.0 */publicclass ThreadDemo2 {    publicstaticvoid main(String[] args) {        System.out.println(&quot;-----多线程创建开始-----&quot;);        // 1.创建一个线程        CreateRunnable createThread = new CreateRunnable();        // 2.开始执行线程 注意 开启线程不是调用run方法，而是start方法        System.out.println(&quot;-----多线程创建启动-----&quot;);        Thread thread = new Thread(createThread);        thread.start();        System.out.println(&quot;-----多线程创建结束-----&quot;);    }}</code></pre><ol start="3"><li>使用匿名内部类</li></ol><pre><code class="java">    //在main函数里面直接写子线程方法     System.out.println(&quot;-----多线程创建开始-----&quot;);         Thread thread = new Thread(new Runnable() {            public void run() {                for (int i = 0; i&lt; 10; i++) {                    System.out.println(&quot;i:&quot; + i);                }            }        });         thread.start();         System.out.println(&quot;-----多线程创建结束-----&quot;);</code></pre><h4 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h4><ul><li>Q:<strong>那么相对于前面两种方法，那种方法比较好?</strong><blockquote><p> A:使用接口比较好，因为java只能实现单继承，但是可以实现多种接口。而且公司开发大多都是面向接口编程。</p></blockquote><h4 id="多线程常用API"><a href="#多线程常用API" class="headerlink" title="多线程常用API"></a>多线程常用API</h4></li></ul><table><thead><tr><th style="text-align:left">常用API</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">start()</td><td style="text-align:left">启动线程</td></tr><tr><td style="text-align:left">CurrentThread()</td><td style="text-align:left">当前线程</td></tr><tr><td style="text-align:left">getID()</td><td style="text-align:left">获取当前线程ID      Thread-编号  该编号从0开始</td></tr><tr><td style="text-align:left">getName()</td><td style="text-align:left">获取当前线程名称</td></tr><tr><td style="text-align:left">sleep(long mill)</td><td style="text-align:left">设置线程执行时间(ms)</td></tr></tbody></table><table><thead><tr><th style="text-align:left">常用线程构造函数</th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left">Thread()</td><td style="text-align:left">分配一个新的Thread对象</td></tr><tr><td style="text-align:left">Thread（String name）</td><td style="text-align:left">分配一个新的Thread 对象，并且指定线程名称</td></tr><tr><td style="text-align:left">Thread(Runable r)</td><td style="text-align:left">分配一个新的Thread对象</td></tr><tr><td style="text-align:left">Thread(Runable r,String name)</td><td style="text-align:left">分配一个新的Thread对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java架构 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>大家好，我是WHOAMI。欢迎来到我的个人技术博客。</p><blockquote><p>低头做事，抬头装X</p></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
